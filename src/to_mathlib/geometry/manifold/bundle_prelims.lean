import geometry.manifold.diffeomorph

open bundle set function
open_locale manifold topological_space

def model_with_corners.simps.apply (ùïú : Type*) [nondiscrete_normed_field ùïú]
  (E : Type*) [normed_group E] [normed_space ùïú E] (H : Type*) [topological_space H]
  (I : model_with_corners ùïú E H) : H ‚Üí E := I

def model_with_corners.simps.symm_apply (ùïú : Type*) [nondiscrete_normed_field ùïú]
  (E : Type*) [normed_group E] [normed_space ùïú E] (H : Type*) [topological_space H]
  (I : model_with_corners ùïú E H) : E ‚Üí H := I.symm

initialize_simps_projections model_with_corners
  (to_local_equiv_to_fun ‚Üí apply, to_local_equiv_inv_fun ‚Üí symm_apply,
   to_local_equiv_source ‚Üí source, to_local_equiv_target ‚Üí target, -to_local_equiv)

attribute [ext] topological_fiber_bundle.pretrivialization
attribute [ext] topological_fiber_bundle.trivialization
attribute [ext] topological_vector_bundle.pretrivialization
attribute [ext] topological_vector_bundle.trivialization
attribute [simps] model_with_corners.prod tangent_bundle_core
attribute [simps coord_change index_at]
  basic_smooth_vector_bundle_core.to_topological_vector_bundle_core
attribute [simps chart_at] basic_smooth_vector_bundle_core.to_charted_space

-- lemma Exists.const_snd {Œ± : Sort*} {p : Prop} : (‚àÉ x : Œ±, p) ‚Üí p
-- | ‚ü®x, h‚ü© := h

-- lemma Exists.snd_fst {Œ± : Sort*} {p : Prop} {q : Œ± ‚Üí Prop} (h : ‚àÉ x, p ‚àß q x) : p :=
-- (exists_imp_exists (Œª x, and.left) h).const_snd

/- These lemmas have the wrong name -/
lemma id_comp {Œ± Œ≤ : Sort*} (f : Œ± ‚Üí Œ≤) : id ‚àò f = f := rfl -- function.comp.left_id
lemma comp_id {Œ± Œ≤ : Sort*} (f : Œ± ‚Üí Œ≤) : f ‚àò id = f := rfl -- function.comp.right_id
lemma id_apply {Œ± : Sort*} (x : Œ±) : id x = x := rfl -- id.def

namespace set

variables {Œ± Œ≤ Œ≥ Œ¥ : Type*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s s‚ÇÅ : set Œ±} {t t‚ÇÅ : set Œ≤} {x : Œ±} {y : Œ≤}

lemma prod_eq_prod_iff_of_nonempty (h : (s √óÀ¢ t : set _).nonempty) :
  s √óÀ¢ t = s‚ÇÅ √óÀ¢ t‚ÇÅ ‚Üî s = s‚ÇÅ ‚àß t = t‚ÇÅ :=
begin
  split,
  { intro heq,
    have h‚ÇÅ : (s‚ÇÅ √óÀ¢ t‚ÇÅ : set _).nonempty, { rwa [‚Üê heq] },
    rw [prod_nonempty_iff] at h h‚ÇÅ,
    rw [‚Üê fst_image_prod s h.2, ‚Üê fst_image_prod s‚ÇÅ h‚ÇÅ.2, heq, eq_self_iff_true, true_and,
        ‚Üê snd_image_prod h.1 t, ‚Üê snd_image_prod h‚ÇÅ.1 t‚ÇÅ, heq] },
  { rintro ‚ü®rfl, rfl‚ü©, refl }
end

lemma prod_eq_prod_iff : s √óÀ¢ t = s‚ÇÅ √óÀ¢ t‚ÇÅ ‚Üî s = s‚ÇÅ ‚àß t = t‚ÇÅ ‚à® (s = ‚àÖ ‚à® t = ‚àÖ) ‚àß
  (s‚ÇÅ = ‚àÖ ‚à® t‚ÇÅ = ‚àÖ) :=
begin
  symmetry,
  cases eq_empty_or_nonempty (s √óÀ¢ t) with h h,
  { simp_rw [h, @eq_comm _ ‚àÖ, prod_eq_empty_iff, prod_eq_empty_iff.mp h, true_and,
      or_iff_right_iff_imp],
    rintro ‚ü®rfl, rfl‚ü©, exact prod_eq_empty_iff.mp h },
  rw [prod_eq_prod_iff_of_nonempty h],
  rw [‚Üê ne_empty_iff_nonempty, ne.def, prod_eq_empty_iff] at h,
  simp_rw [h, false_and, or_false],
end

-- def mk_image2 (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (x : s) (y : t) : image2 f s t :=
-- ‚ü®f x y, mem_image2_of_mem x.2 y.2‚ü©

lemma image2.some_prop (z : image2 f s t) : ‚àÉ (y : s √ó t), f y.1 y.2 = z :=
let ‚ü®_, ‚ü®x, y, hx, hy, rfl‚ü©‚ü© := z in ‚ü®‚ü®‚ü®x, hx‚ü©, ‚ü®y, hy‚ü©‚ü©, rfl‚ü©

noncomputable def image2.some (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : set Œ±) (t : set Œ≤) (z : image2 f s t) : s √ó t :=
classical.some (image2.some_prop z)

lemma image2.some_spec (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hx : x ‚àà s) (hy : y ‚àà t) :
  (Œª x : s √ó t, f x.1 x.2) (image2.some f s t ‚ü®f x y, mem_image2_of_mem hx hy‚ü©) = f x y :=
classical.some_spec (image2.some_prop ‚ü®f x y, mem_image2_of_mem hx hy‚ü©)

lemma image2.some_spec_fst (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hx : x ‚àà s) (hy : y ‚àà t) : ‚àÉ y' ‚àà t,
  f (image2.some f s t ‚ü®f x y, mem_image2_of_mem hx hy‚ü©).1 y' = f x y :=
‚ü®(image2.some f s t ‚ü®f x y, mem_image2_of_mem hx hy‚ü©).2, subtype.mem _, image2.some_spec f hx hy‚ü©

lemma image2.some_spec_snd (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (hx : x ‚àà s) (hy : y ‚àà t) : ‚àÉ x' ‚àà s,
  f x' (image2.some f s t ‚ü®f x y, mem_image2_of_mem hx hy‚ü©).2 = f x y :=
‚ü®(image2.some f s t ‚ü®f x y, mem_image2_of_mem hx hy‚ü©).1, subtype.mem _, image2.some_spec f hx hy‚ü©

end set

namespace local_homeomorph

variables {Œ± Œ≤ Œ≥ Œ¥ : Type*} [topological_space Œ±] [topological_space Œ≤]
variables [topological_space Œ≥] [topological_space Œ¥] {e : local_homeomorph Œ± Œ≤}

lemma trans_apply {e‚ÇÅ : local_homeomorph Œ± Œ≤} {e‚ÇÇ : local_homeomorph Œ≤ Œ≥} {x : Œ±} :
  (e‚ÇÅ ‚â´‚Çï e‚ÇÇ) x = e‚ÇÇ (e‚ÇÅ x) :=
rfl

protected lemma ext_iff {e e' : local_homeomorph Œ± Œ≤} : e = e' ‚Üî (‚àÄ x, e x = e' x) ‚àß
  (‚àÄ x, e.symm x = e'.symm x) ‚àß e.source = e'.source :=
‚ü®by { rintro rfl, exact ‚ü®Œª x, rfl, Œª x, rfl, rfl‚ü© }, Œª h, e.ext e' h.1 h.2.1 h.2.2‚ü©

lemma image_source_eq_target (e : local_homeomorph Œ± Œ≤) : e '' e.source = e.target :=
e.to_local_equiv.image_source_eq_target

lemma source_subset_preimage_target : e.source ‚äÜ e ‚Åª¬π' e.target :=
e.maps_to

lemma symm_image_target_eq_source (e : local_homeomorph Œ± Œ≤) : e.symm '' e.target = e.source :=
e.symm.image_source_eq_target

lemma target_subset_preimage_source : e.target ‚äÜ e.symm ‚Åª¬π' e.source :=
e.symm_maps_to

example {Œ± : Type*} (p : Prop) [nonempty Œ±] : (Œ± ‚Üí p) ‚Üî p :=
by simp only [forall_const]

example {Œ± Œ≤ : Type*} (p : Œ≤ ‚Üí Prop) [h : nonempty Œ±] : (‚àÄ x : Œ≤, id x = x) ‚Üî ‚àÄ x : Œ≤, x = x :=
by simp only [id]

@[simp] lemma forall_forall_const {Œ± Œ≤ : Type*} (p : Œ≤ ‚Üí Prop) [h : nonempty Œ±] :
  (‚àÄ x, Œ± ‚Üí p x) ‚Üî ‚àÄ x, p x :=
forall_congr $ Œª x, forall_const Œ± -- for some reason simp doesn't like this

lemma prod_eq_prod_of_nonempty {e‚ÇÅ e‚ÇÅ' : local_homeomorph Œ± Œ≤} {e‚ÇÇ e‚ÇÇ' : local_homeomorph Œ≥ Œ¥}
  (h : (e‚ÇÅ.prod e‚ÇÇ).source.nonempty) :
  e‚ÇÅ.prod e‚ÇÇ = e‚ÇÅ'.prod e‚ÇÇ' ‚Üî e‚ÇÅ = e‚ÇÅ' ‚àß e‚ÇÇ = e‚ÇÇ' :=
begin
  obtain ‚ü®‚ü®x, y‚ü©, -‚ü© := id h,
  have : nonempty Œ± := ‚ü®x‚ü©,
  have : nonempty Œ≤  := ‚ü®e‚ÇÅ x‚ü©,
  have : nonempty Œ≥ := ‚ü®y‚ü©,
  haveI : nonempty Œ¥ := ‚ü®e‚ÇÇ y‚ü©,
  simp_rw [local_homeomorph.ext_iff, prod_apply, prod_symm_apply, prod_source, prod.ext_iff,
    set.prod_eq_prod_iff_of_nonempty h,
    forall_and_distrib, prod.forall, forall_const, forall_forall_const, and_assoc, and.left_comm]
end

lemma prod_eq_prod_of_nonempty' {e‚ÇÅ e‚ÇÅ' : local_homeomorph Œ± Œ≤} {e‚ÇÇ e‚ÇÇ' : local_homeomorph Œ≥ Œ¥}
  (h : (e‚ÇÅ'.prod e‚ÇÇ').source.nonempty) :
  e‚ÇÅ.prod e‚ÇÇ = e‚ÇÅ'.prod e‚ÇÇ' ‚Üî e‚ÇÅ = e‚ÇÅ' ‚àß e‚ÇÇ = e‚ÇÇ' :=
by rw [eq_comm, prod_eq_prod_of_nonempty h, eq_comm, @eq_comm _ e‚ÇÇ']

end local_homeomorph

namespace topological_fiber_bundle
namespace trivialization


variables {Œπ : Type*} {B : Type*} {F : Type*} {Z : Type*} {proj : Z ‚Üí B}
variables [topological_space B] [topological_space F] [topological_space Z]

lemma to_pretrivialization_injective :
  injective (Œª e : trivialization F proj, e.to_pretrivialization) :=
by { intros e e', rw [pretrivialization.ext_iff, trivialization.ext_iff,
  ‚Üê local_homeomorph.to_local_equiv_injective.eq_iff], exact id }

end trivialization
end topological_fiber_bundle

namespace topological_vector_bundle

variables {R : Type*} {B : Type*} {F : Type*} {E : B ‚Üí Type*}
variables [nondiscrete_normed_field R] [‚àÄ x, add_comm_monoid (E x)] [‚àÄ x, module R (E x)]
  [normed_group F] [normed_space R F] [topological_space B]
  [topological_space (total_space E)]

namespace trivialization

lemma to_pretrivialization_injective :
  injective (Œª e : trivialization R F E, e.to_pretrivialization) :=
by { intros e e', rw [pretrivialization.ext_iff, trivialization.ext_iff,
  ‚Üê topological_fiber_bundle.trivialization.to_pretrivialization_injective.eq_iff], exact id }

end trivialization

variables {HB : Type*} [topological_space HB]

/-- The chart of the total space by a bundle given by a trivialization along a chart of the base
  space. -/
def chart_at (e : trivialization R F E) (f : local_homeomorph B HB) :
  local_homeomorph (total_space E) (model_prod HB F) :=
e.to_local_homeomorph.trans $ f.prod $ local_homeomorph.refl F

variables (R F E) [‚àÄ x, topological_space (E x)]

/-- The total space of a topological vector bundle forms a charted space.
Currently not an instance, because it creates the metavariable `R`, but it might be fine to change
this. -/
def total_space.to_charted_space [topological_vector_bundle R F E] [charted_space HB B] :
  charted_space (model_prod HB F) (total_space E) :=
{ atlas := image2 chart_at (trivialization_atlas R F E) (atlas HB B),
  chart_at := Œª x, chart_at (trivialization_at R F E x.proj) (charted_space.chart_at HB x.proj),
  mem_chart_source := Œª x, by simp only [chart_at, trivialization.mem_source,
    mem_base_set_trivialization_at R F E x.proj] with mfld_simps,
  chart_mem_atlas := Œª x, mem_image2_of_mem (trivialization_mem_atlas R F E x.proj)
    (chart_mem_atlas HB x.proj) }

end topological_vector_bundle

section charted_space

variables {M H : Type*} [topological_space M] [topological_space H] [charted_space H M]
  (G : structure_groupoid H)

lemma structure_groupoid.subset_maximal_atlas [has_groupoid M G] : atlas H M ‚äÜ G.maximal_atlas M :=
Œª e he e' he', ‚ü®G.compatible he he', G.compatible he' he‚ü©

variable (H)
/-- `achart H x` is the chart at `x`, considered as an element of the atlas. -/
def achart (x : M) : atlas H M := ‚ü®chart_at H x, chart_mem_atlas H x‚ü©

lemma achart_def (x : M) : achart H x = ‚ü®chart_at H x, chart_mem_atlas H x‚ü© := rfl
@[simp] lemma coe_achart (x : M) : (achart H x : local_homeomorph M H) = chart_at H x := rfl
@[simp] lemma achart_val (x : M) : (achart H x).1 = chart_at H x := rfl

variable {H}

end charted_space

namespace model_with_corners

variables {ùïú : Type*} [nondiscrete_normed_field ùïú]
  {E : Type*} [normed_group E] [normed_space ùïú E]
  {H : Type*} [topological_space H]
  {M : Type*} [topological_space M] (f : local_homeomorph M H) (I : model_with_corners ùïú E H)

lemma injective : injective I :=
left_inverse.injective I.left_inv

lemma preimage_image (s : set H) : I ‚Åª¬π' (I '' s) = s :=
I.injective.preimage_image s

/-- Given a chart `f` on a manifold with corners, `f.extend` is the extended chart to the model
vector space. -/
@[simp, mfld_simps] def _root_.local_homeomorph.extend : local_equiv M E :=
f.to_local_equiv ‚â´ I.to_local_equiv

lemma _root_.local_homeomorph.extend_source : (f.extend I).source = f.source :=
by rw [local_homeomorph.extend, local_equiv.trans_source, I.source_eq, preimage_univ, inter_univ]

lemma _root_.local_homeomorph.extend_target : (f.extend I).target = I '' f.target :=
by rw [local_homeomorph.extend, local_equiv.trans_target, I.target_eq, I.image_eq, inter_comm,
  I.to_local_equiv_coe_symm]

end model_with_corners

namespace structure_groupoid.local_invariant_properties

variables {H : Type*} {M : Type*} [topological_space H] [topological_space M] [charted_space H M]
{H' : Type*} {M' : Type*} [topological_space H'] [topological_space M'] [charted_space H' M']

variables {G : structure_groupoid H} {G' : structure_groupoid H'}
{e e' : local_homeomorph M H} {f f' : local_homeomorph M' H'}
{P : (H ‚Üí H') ‚Üí set H ‚Üí H ‚Üí Prop} {g g' : M ‚Üí M'} {s t : set M} {x : M}
{Q : (H ‚Üí H) ‚Üí set H ‚Üí H ‚Üí Prop}
variable (hG : G.local_invariant_prop G' P)
include hG

-- lemma lift_prop_within_at_indep_chart_target [has_groupoid M' G']
--   (hf : f ‚àà G'.maximal_atlas M') (xf : g x ‚àà f.source) :
--   lift_prop_within_at P g s x ‚Üî
--     /-continuous_within_at g s x ‚àß-/
--     lift_prop_within_at P (f ‚àò g) s x :=
-- begin
--   split,
--   { intro hg,
--     refine ‚ü®(f.continuous_at _).comp_continuous_within_at hg.1, _‚ü©,  },
--   { }
-- end

-- lemma lift_prop_within_at_indep_chart_source [has_groupoid M G] [has_groupoid M' G']
--   (he : e ‚àà G.maximal_atlas M) (xe : x ‚àà e.source)
--   (hf : f ‚àà G'.maximal_atlas M') (xf : g x ‚àà f.source) :
--   lift_prop_within_at P g s x ‚Üî
--     continuous_within_at g s x ‚àß P (f ‚àò g ‚àò e.symm)
--       (e.target ‚à© e.symm ‚Åª¬π' (s ‚à© g‚Åª¬π' f.source)) (e x) :=
-- sorry

end structure_groupoid.local_invariant_properties

section smooth_manifold_with_corners
open smooth_manifold_with_corners

variables {ùïú : Type*} [nondiscrete_normed_field ùïú]
  {E : Type*} [normed_group E] [normed_space ùïú E]
  {E' : Type*} [normed_group E'] [normed_space ùïú E']
  {H : Type*} [topological_space H] {I : model_with_corners ùïú E H}
  {H' : Type*} [topological_space H'] {I' : model_with_corners ùïú E' H'}
  {M : Type*} [topological_space M] [charted_space H M]
  {M' : Type*} [topological_space M'] [charted_space H' M']
variables {f : M ‚Üí M'} {m n : with_top ‚Ñï} {s : set M} {x : M}


lemma smooth_manifold_with_corners.subset_maximal_atlas [smooth_manifold_with_corners I M] :
  atlas H M ‚äÜ maximal_atlas I M :=
structure_groupoid.subset_maximal_atlas _

lemma cont_mdiff_at_iff_target
  [smooth_manifold_with_corners I' M']
  {x : M} :
  cont_mdiff_at I I' n f x ‚Üî
    continuous_at f x ‚àß cont_mdiff_at I ùìò(ùïú, E') n (ext_chart_at I' (f x) ‚àò f) x :=
by rw [cont_mdiff_at, cont_mdiff_at, cont_mdiff_within_at_iff_target, continuous_within_at_univ]

lemma cont_mdiff_within_at_iff_target_of_mem_source_chart_at
  [smooth_manifold_with_corners I' M']
  {x : M} {y : M'} (hy : f x ‚àà (chart_at H' y).source) :
  cont_mdiff_within_at I I' n f s x ‚Üî continuous_within_at f s x ‚àß
    cont_mdiff_within_at I ùìò(ùïú, E') n (ext_chart_at I' y ‚àò f) s x :=
begin
  -- rw [cont_mdiff_within_at_iff_target, and.congr_right_iff],
  -- intro hf,
  -- have := (cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart_aux
  --   (chart_mem_maximal_atlas I),
  sorry -- useful, but currently unused
  -- combination of `cont_mdiff_within_at_iff_target` and `cont_mdiff_within_at_iff_of_mem_source`
  -- probably needs generalization of `lift_prop_within_at_indep_chart_aux` that does only one side,
  -- and only assumes that that side is a manifold with corners
end

lemma cont_mdiff_at_iff_target_of_mem_source_chart_at
  [smooth_manifold_with_corners I' M']
  {x : M} {y : M'} (hy : f x ‚àà (chart_at H' y).source) :
  cont_mdiff_at I I' n f x ‚Üî continuous_at f x ‚àß
    cont_mdiff_at I ùìò(ùïú, E') n (ext_chart_at I' y ‚àò f) x :=
begin
  rw [cont_mdiff_at, cont_mdiff_within_at_iff_target_of_mem_source_chart_at hy,
    continuous_within_at_univ, cont_mdiff_at],
  apply_instance
end

variables (I)

lemma cont_diff_on_coord_change [smooth_manifold_with_corners I M]
  {e e' : local_homeomorph M H} (h : e ‚àà atlas H M) (h' : e' ‚àà atlas H M) :
  cont_diff_on ùïú ‚ä§ (I ‚àò (e.symm ‚â´‚Çï e') ‚àò I.symm) (I.symm ‚Åª¬π' (e.symm ‚â´‚Çï e').source ‚à© range I) :=
(has_groupoid.compatible (cont_diff_groupoid ‚ä§ I) h h').1

lemma cont_diff_on_coord_change_symm [smooth_manifold_with_corners I M]
  {e e' : local_homeomorph M H} (h : e ‚àà atlas H M) (h' : e' ‚àà atlas H M) :
  cont_diff_on ùïú ‚ä§ (I ‚àò (e.symm ‚â´‚Çï e') ‚àò I.symm) (I.symm ‚Åª¬π' (e.symm ‚â´‚Çï e').source ‚à© range I) :=
(has_groupoid.compatible (cont_diff_groupoid ‚ä§ I) h h').1

variables {I} [smooth_manifold_with_corners I M] [smooth_manifold_with_corners I' M']

/-- One can reformulate smoothness within a set at a point as continuity within this set at this
point, and smoothness in any chart containing that point. -/
lemma cont_mdiff_within_at_iff_of_mem_maximal_atlas
  {c : local_homeomorph M H} (hc : c ‚àà maximal_atlas I M)
  {d : local_homeomorph M' H'} (hd : d ‚àà maximal_atlas I' M')
  (hx : x ‚àà c.source) (hy : f x ‚àà d.source) :
  cont_mdiff_within_at I I' n f s x ‚Üî continuous_within_at f s x ‚àß
    cont_diff_within_at ùïú n (d.extend I' ‚àò f ‚àò (c.extend I).symm)
    ((c.extend I).symm ‚Åª¬π' s ‚à© range I)
    (c.extend I x) :=
(cont_diff_within_at_local_invariant_prop I I' n).lift_prop_within_at_indep_chart hc hx hd hy

/-
todo: `((ext_chart_at I x).symm ‚Åª¬π' s ‚à© range I)` in `cont_mdiff.lean` is not very nice,
since it doesn't have to be a subset of `(ext_chart_at I x).target`, which is annoying.
Of course, near `(ext_chart_at I x x)` it's the same.
Also do this in file `mfderiv`
-/

/-- One can reformulate smoothness on a set as continuity on this set, and smoothness in two given
charts that contain the set. -/
lemma cont_mdiff_on_iff_of_subset_source
  {c : local_homeomorph M H} (hc : c ‚àà maximal_atlas I M)
  {d : local_homeomorph M' H'} (hd : d ‚àà maximal_atlas I' M')
  (hs : s ‚äÜ c.source) (h2s : f '' s ‚äÜ d.source) :
  cont_mdiff_on I I' n f s ‚Üî continuous_on f s ‚àß
    cont_diff_on ùïú n (d.extend I' ‚àò f ‚àò (c.extend I).symm) (c.extend I '' s) :=
begin
  split,
  { refine Œª H, ‚ü®H.continuous_on, _‚ü©,
    rintro _ ‚ü®x', hx', rfl‚ü©,
    refine ((cont_mdiff_within_at_iff_of_mem_maximal_atlas hc hd (hs hx')
      (h2s $ mem_image_of_mem f hx')).mp (H _ hx')).2.mono _,
    rw [(c.extend I).image_eq_target_inter_inv_preimage _, inter_comm, c.extend_target],
    refine inter_subset_inter subset.rfl (image_subset_range _ _),
    rwa [c.extend_source] },
  { rintro ‚ü®h1, h2‚ü© x' hx',
    refine (cont_mdiff_within_at_iff_of_mem_maximal_atlas hc hd (hs hx')
      (h2s $ mem_image_of_mem f hx')).mpr ‚ü®h1.continuous_within_at hx', _‚ü©,
    refine (h2 _ $ mem_image_of_mem _ hx').mono_of_mem _,
    sorry -- easy, but even easier after above todo
     }
end

-- rename or remove depending on whether this is useful
lemma cont_mdiff_on_iff_of_subset_source_chart_at {x : M} {y : M'}
  (hs : s ‚äÜ (chart_at H x).source)
  (h2s : f '' s ‚äÜ (chart_at H' y).source) :
  cont_mdiff_on I I' n f s ‚Üî continuous_on f s ‚àß
    cont_diff_on ùïú n (ext_chart_at I' y ‚àò f ‚àò (ext_chart_at I x).symm)
    (ext_chart_at I x '' s) :=
cont_mdiff_on_iff_of_subset_source (structure_groupoid.chart_mem_maximal_atlas _ x)
  (structure_groupoid.chart_mem_maximal_atlas _ y) hs h2s

lemma smooth_on_iff_of_subset_source
  {c : local_homeomorph M H} (hc : c ‚àà maximal_atlas I M)
  {d : local_homeomorph M' H'} (hd : d ‚àà maximal_atlas I' M')
  (hs : s ‚äÜ c.source) (h2s : f '' s ‚äÜ d.source) :
  smooth_on I I' f s ‚Üî continuous_on f s ‚àß
    cont_diff_on ùïú ‚ä§ (d.extend I' ‚àò f ‚àò (c.extend I).symm)
    (c.extend I '' s) :=
cont_mdiff_on_iff_of_subset_source hc hd hs h2s

variables {F G F' : Type*}
variables [normed_group F] [normed_group G] [normed_group F']
variables [normed_space ùïú F] [normed_space ùïú G] [normed_space ùïú F']

lemma cont_diff_within_at.comp_cont_mdiff_within_at {g : F ‚Üí G} {f : M ‚Üí F} {s : set M} {t : set F}
  {x : M}
  (hg : cont_diff_within_at ùïú n g t (f x))
  (hf : cont_mdiff_within_at I ùìò(ùïú, F) n f s x) (h : s ‚äÜ f ‚Åª¬π' t) :
  cont_mdiff_within_at I ùìò(ùïú, G) n (g ‚àò f) s x :=
begin
  rw cont_mdiff_within_at_iff at *,
  refine ‚ü®hg.continuous_within_at.comp hf.1 h, _‚ü©,
  -- simp_rw [written_in_ext_chart_at, ext_chart_model_space_eq_id, local_equiv.refl_coe,
  --   id_comp] at hf ‚ä¢,
  rw [‚Üê (ext_chart_at I x).left_inv (mem_ext_chart_source I x)] at hg,
  apply cont_diff_within_at.comp _ (by exact hg) hf.2 _,
  -- rw [@preimage_comp _ _ _ _ f],
  exact (inter_subset_left _ _).trans (preimage_mono h)
end

lemma cont_diff_at.comp_cont_mdiff_at {g : F ‚Üí G} {f : M ‚Üí F} {x : M}
  (hg : cont_diff_at ùïú n g (f x)) (hf : cont_mdiff_at I ùìò(ùïú, F) n f x) :
  cont_mdiff_at I ùìò(ùïú, G) n (g ‚àò f) x :=
hg.comp_cont_mdiff_within_at hf subset.rfl

lemma cont_diff.comp_cont_mdiff {g : F ‚Üí G} {f : M ‚Üí F}
  (hg : cont_diff ùïú n g) (hf : cont_mdiff I ùìò(ùïú, F) n f) :
  cont_mdiff I ùìò(ùïú, G) n (g ‚àò f) :=
Œª x, hg.cont_diff_at.comp_cont_mdiff_at (hf x)

-- lemma cont_mdiff_within_at.clm_comp {g : M ‚Üí F ‚ÜíL[ùïú] G} {f : M ‚Üí E ‚ÜíL[ùïú] F} {s : set M} {x : M}
--   (hg : cont_mdiff_within_at I ùìò(ùïú, F ‚ÜíL[ùïú] G) n g s x)
--   (hf : cont_mdiff_within_at I ùìò(ùïú, E ‚ÜíL[ùïú] F) n f s x) :
--   cont_mdiff_within_at I ùìò(ùïú, E ‚ÜíL[ùïú] G) n (Œª x, (g x).comp (f x)) s x :=
-- sorry

-- the following proof takes very long in pure term mode
lemma cont_mdiff_at.clm_comp {g : M ‚Üí F ‚ÜíL[ùïú] G} {f : M ‚Üí F' ‚ÜíL[ùïú] F} {x : M}
  (hg : cont_mdiff_at I ùìò(ùïú, F ‚ÜíL[ùïú] G) n g x) (hf : cont_mdiff_at I ùìò(ùïú, F' ‚ÜíL[ùïú] F) n f x) :
  cont_mdiff_at I ùìò(ùïú, F' ‚ÜíL[ùïú] G) n (Œª x, (g x).comp (f x)) x :=
@cont_diff_at.comp_cont_mdiff_at ùïú _ E _ _ H _ I M _ _ n _ ((F ‚ÜíL[ùïú] G) √ó (F' ‚ÜíL[ùïú] F))
  _ _ _ _ _
  (Œª x, continuous_linear_map.comp x.1 x.2) (Œª x, (g x, f x)) x
  (by { apply cont_diff.cont_diff_at, apply is_bounded_bilinear_map.cont_diff, exact is_bounded_bilinear_map_comp,  }) (hg.prod_mk_space hf)

open filter
lemma cont_mdiff.clm_comp {g : M ‚Üí F ‚ÜíL[ùïú] G} {f : M ‚Üí F' ‚ÜíL[ùïú] F}
  (hg : cont_mdiff I ùìò(ùïú, F ‚ÜíL[ùïú] G) n g) (hf : cont_mdiff I ùìò(ùïú, F' ‚ÜíL[ùïú] F) n f) :
  cont_mdiff I ùìò(ùïú, F' ‚ÜíL[ùïú] G) n (Œª x, (g x).comp (f x)) :=
Œª x, (hg x).clm_comp (hf x)

lemma cont_mdiff_at.mfderiv' {f : M ‚Üí M'}
  (hf : cont_mdiff_at I I' n f x) (hmn : m + 1 ‚â§ n) :
  cont_mdiff_at I ùìò(ùïú, E ‚ÜíL[ùïú] E') m
  (Œª x', (tangent_bundle_core I' M').coord_change (achart H' (f x')) (achart H' (f x))
    (chart_at H' (f x') (f x')) ‚àòL mfderiv I I' f x' ‚àòL
    (tangent_bundle_core I M).coord_change (achart H x) (achart H x') (chart_at H x x')) x :=
begin
  have hn : 1 ‚â§ n := (self_le_add_left 1 m).trans hmn,
  obtain ‚ü®u, hu, hfu‚ü© := cont_mdiff_at_iff_cont_mdiff_on_nhds.mp (hf.of_le hn),
  have : ‚àÄ·∂† x' in ùìù x, differentiable_within_at ùïú (written_in_ext_chart_at I I' x' f) (range I)
    (ext_chart_at I x' $ (ext_chart_at I x').symm $ ext_chart_at I x' x'),
  { sorry },
  have : cont_mdiff_at I ùìò(ùïú, E ‚ÜíL[ùïú] E') m
    (Œª x', fderiv_within ùïú (written_in_ext_chart_at I I' x f) (range I) (ext_chart_at I x x')) x,
  {
    sorry
    -- refine cont_mdiff_at.congr_of_eventually_eq _ (eventually_of_mem hu _),
    -- swap 3,
    -- intros x' hx',
    -- have := ((hfu x' hx').mdifferentiable_within_at le_rfl).2,
   },
  have : cont_mdiff_at I ùìò(ùïú, E ‚ÜíL[ùïú] E') m
    (Œª x', fderiv_within ùïú (ext_chart_at I' (f x) ‚àò (ext_chart_at I' (f x')).symm ‚àò
      written_in_ext_chart_at I I' x' f ‚àò ext_chart_at I x' ‚àò (ext_chart_at I x).symm)
      (range I) (ext_chart_at I x x')) x,
  { refine this.congr_of_eventually_eq
      (eventually_of_mem (ext_chart_at_source_mem_nhds I x) (Œª x‚ÇÇ hx‚ÇÇ, _)),
    have : ‚àÄ x', (ext_chart_at I' (f x) ‚àò (ext_chart_at I' (f x‚ÇÇ)).symm ‚àò
      written_in_ext_chart_at I I' x‚ÇÇ f ‚àò ext_chart_at I x‚ÇÇ ‚àò (ext_chart_at I x).symm) x' =
      written_in_ext_chart_at I I' x f x',
    { intros x', -- restrict x'
      simp_rw [written_in_ext_chart_at, function.comp_apply],
      rw [(ext_chart_at I x‚ÇÇ).left_inv, (ext_chart_at I' (f x‚ÇÇ)).left_inv],
      sorry, sorry,
      },
    refine eventually_eq.fderiv_within_eq (I.unique_diff _ $ mem_range_self _) _ (this _),
    refine eventually_of_forall (Œª x', _),
    apply this,
    },
  have hI := (tangent_bundle_core I M).coord_change_smooth_clm,
  have hI' := (tangent_bundle_core I' M').coord_change_smooth_clm,
  simp_rw [function.comp, tangent_bundle_core_coord_change] at hI hI' ‚ä¢,
  change cont_mdiff_at I ùìò(ùïú, E ‚ÜíL[ùïú] E') m
    (Œª x', (fderiv_within ùïú (ext_chart_at I' (f x) ‚àò (ext_chart_at I' (f x')).symm)
        (range I') (ext_chart_at I' (f x') (f x'))).comp ((mfderiv I I' f x').comp
          (fderiv_within ùïú (ext_chart_at I x' ‚àò (ext_chart_at I x).symm)
             (range I) (ext_chart_at I x x')))) x,
  have := (hf.mdifferentiable_at hn).mfderiv,
  have := (hf.mdifferentiable_at hn).2,
  have := @fderiv_within.comp,
end

-- todo fix
lemma cont_mdiff_at_iff_cont_mdiff_on_nhds' {n : with_top ‚Ñï} :
  cont_mdiff_at I I' n f x ‚Üî ‚àÉ u ‚àà ùìù x, cont_mdiff_on I I' n f u :=
by sorry

lemma cont_mdiff.mfderiv' {f : M ‚Üí M'}
  (hf : cont_mdiff I I' n f) (hmn : m + 1 ‚â§ n) :
  cont_mdiff_at I ùìò(ùïú, E ‚ÜíL[ùïú] E') m
  (Œª x', ((tangent_bundle_core I' M').coord_change (achart H' (f x')) (achart H' (f x)) $
    chart_at H' (f x') (f x')).comp $
    (mfderiv I I' f x').comp $
    (tangent_bundle_core I M).coord_change (achart H x) (achart H x') $ chart_at H x x') x :=
begin
  have hn : 1 ‚â§ n := (self_le_add_left 1 m).trans hmn,
  have := (hf.cont_mdiff_at.mdifferentiable_at hn).mfderiv,
  have hI := (tangent_bundle_core I M).coord_change_smooth_clm,
  have hI' := (tangent_bundle_core I' M').coord_change_smooth_clm,
  simp_rw [function.comp, tangent_bundle_core_coord_change] at hI hI' ‚ä¢,
  simp_rw [(hf.cont_mdiff_at.mdifferentiable_at hn).mfderiv],
  have := (hf.cont_mdiff_at.mdifferentiable_at hn).2,
  have := @fderiv_within.comp,
end

end smooth_manifold_with_corners

namespace local_equiv

variables {Œ± Œ≤ Œ≥ : Type*}

/-- This might be useful to formulate many "composition of `f` and `g` is given by `h`" notions,
like `coord_change_comp` in various structures. -/
def eq_on_common_source (e e' : local_equiv Œ± Œ≤) : Prop :=
‚àÄ x ‚àà e.source ‚à© e'.source, e x = e' x

end local_equiv


namespace basic_smooth_vector_bundle_core

variables {ùïú B B' M VB VB' VM HB HB' HM : Type*}
variables [nondiscrete_normed_field ùïú]
variables [normed_group VB] [normed_space ùïú VB] [normed_group VB'] [normed_space ùïú VB']
variables [normed_group VM] [normed_space ùïú VM]
variables [topological_space HB] [topological_space HB'] [topological_space HM]
variables {IB : model_with_corners ùïú VB HB} {IB' : model_with_corners ùïú VB' HB'}
variables {IM : model_with_corners ùïú VM HM}
variables {F F' : Type*}
variables [normed_group F] [normed_space ùïú F] [normed_group F'] [normed_space ùïú F']
variables [topological_space B] [charted_space HB B] [smooth_manifold_with_corners IB B]
variables [topological_space B'] [charted_space HB' B'] [smooth_manifold_with_corners IB' B']
variables [topological_space M] [charted_space HM M] [smooth_manifold_with_corners IM M]
variables (f : C^‚àû‚üÆIB', B'; IB, B‚üØ) -- todo: define cont_mdiff_map_class
variables (Z : basic_smooth_vector_bundle_core IB B F)
variables (Z' : basic_smooth_vector_bundle_core IB B F')

end basic_smooth_vector_bundle_core

section maps

variables {ùïú : Type*} [nondiscrete_normed_field ùïú]
{E : Type*} [normed_group E] [normed_space ùïú E]
{E' : Type*} [normed_group E'] [normed_space ùïú E']
{F : Type*} [normed_group F] [normed_space ùïú F]
{H : Type*} [topological_space H]
{H' : Type*} [topological_space H']
{G : Type*} [topological_space G]
{G' : Type*} [topological_space G']
{I : model_with_corners ùïú E H} {I' : model_with_corners ùïú E' H'}
{J : model_with_corners ùïú F G} {J' : model_with_corners ùïú F G'}

variables {M : Type*} [topological_space M] [charted_space H M]
{M' : Type*} [topological_space M'] [charted_space H' M']
{N : Type*} [topological_space N] [charted_space G N]
{N' : Type*} [topological_space N'] [charted_space G' N']
{n : with_top ‚Ñï}
(f : C^‚àû‚üÆI, M; J, N‚üØ)

namespace cont_mdiff_map

instance : continuous_map_class C^‚àû‚üÆI, M; J, N‚üØ M N :=
{ coe := coe_fn,
  coe_injective' := coe_inj,
  map_continuous := Œª f, f.cont_mdiff_to_fun.continuous }

/-- The first projection of a product, as a smooth map. -/
def fst : C^‚àû‚üÆI.prod I', M √ó M'; I, M‚üØ := ‚ü®prod.fst, cont_mdiff_fst‚ü©

/-- The second projection of a product, as a smooth map. -/
def snd : C^‚àû‚üÆI.prod I', M √ó M'; I', M'‚üØ := ‚ü®prod.snd, cont_mdiff_snd‚ü©

end cont_mdiff_map

namespace diffeomorph

instance : continuous_map_class (M ‚âÉ‚Çò‚üÆI, J‚üØ N) M N :=
{ coe := coe_fn,
  coe_injective' := coe_fn_injective,
  map_continuous := Œª f, f.continuous }

end diffeomorph

end maps
