import global.relation

noncomputable theory

open set function filter (hiding map_smul) charted_space smooth_manifold_with_corners
open_locale topological_space manifold pointwise

section parameter_space
/-! ## Fundamental definitions -/

variables
{E : Type*} [normed_add_comm_group E] [normed_space ‚Ñù E]
{H : Type*} [topological_space H] {I : model_with_corners ‚Ñù E H}
{M : Type*} [topological_space M] [charted_space H M] [smooth_manifold_with_corners I M]
{E' : Type*} [normed_add_comm_group E'] [normed_space ‚Ñù E']
{H' : Type*} [topological_space H'] {I' : model_with_corners ‚Ñù E' H'}
{M' : Type*} [topological_space M'] [charted_space H' M'] [smooth_manifold_with_corners I' M']
{EP : Type*} [normed_add_comm_group EP] [normed_space ‚Ñù EP]
{HP : Type*} [topological_space HP] {IP : model_with_corners ‚Ñù EP HP}
{P : Type*} [topological_space P] [charted_space HP P] [smooth_manifold_with_corners IP P]
{F : Type*} [normed_add_comm_group F] [normed_space ‚Ñù F]
{G : Type*} [topological_space G] {J : model_with_corners ‚Ñù F G}
{N : Type*} [topological_space N] [charted_space G N] [smooth_manifold_with_corners J N]
{EX : Type*} [normed_add_comm_group EX] [normed_space ‚Ñù EX]
{HX : Type*} [topological_space HX] {IX : model_with_corners ‚Ñù EX HX}
-- note: X is a metric space
{X : Type*} [metric_space X] [charted_space HX X] [smooth_manifold_with_corners IX X]
variables {R : rel_mfld I M I' M'}

variables (IP P)

/-- The relation `ùì° ^ P` -/
def rel_mfld.relativize (R : rel_mfld I M I' M') : rel_mfld (IP.prod I) (P √ó M) I' M' :=
bundle_snd ‚Åª¬π' R

variables {IP P}

lemma rel_mfld.mem_relativize (R : rel_mfld I M I' M') (w : one_jet_bundle (IP.prod I) (P √ó M) I' M') :
 w ‚àà R.relativize IP P ‚Üî
  (one_jet_bundle.mk w.1.1.2 w.1.2 (w.2.comp (continuous_linear_map.inr ‚Ñù EP E)) :
    one_jet_bundle I M I' M') ‚àà R :=
by { simp_rw [rel_mfld.relativize, mem_preimage, bundle_snd_eq], refl }

lemma rel_mfld.is_open_relativize (R : rel_mfld I M I' M') (h2 : is_open R) :
  is_open (R.relativize IP P) :=
h2.preimage smooth_bundle_snd.continuous

lemma relativize_slice {œÉ : one_jet_bundle (IP.prod I) (P √ó M) I' M'}
  {p : dual_pair' $ tangent_space (IP.prod I) œÉ.1.1}
  (q : dual_pair' $ tangent_space I œÉ.1.1.2)
  (hpq : p.œÄ.comp (continuous_linear_map.inr ‚Ñù EP E) = q.œÄ) :
  (R.relativize IP P).slice œÉ p =
  œÉ.2 (p.v - (0, q.v)) +·µ• R.slice (bundle_snd œÉ) q :=
begin
  have h2pq : ‚àÄ x : E, p.œÄ ((0 : EP), x) = q.œÄ x := Œª x, congr_arg (Œª f : E ‚ÜíL[‚Ñù] ‚Ñù, f x) hpq,
  ext1 w,
  have h1 : (p.update œÉ.2 w).comp (continuous_linear_map.inr ‚Ñù EP E) =
    q.update (bundle_snd œÉ).2 (-œÉ.2 (p.v - (0, q.v)) +·µ• w),
  { ext1 x,
    simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
      ‚Üê continuous_linear_map.map_neg, neg_sub],
    obtain ‚ü®u, hu, t, rfl‚ü© := q.decomp x,
    have hv : (0, q.v) - p.v ‚àà p.œÄ.ker,
    { rw [continuous_linear_map.mem_ker, map_sub, p.pairing, h2pq, q.pairing, sub_self] },
    have hup : ((0 : EP), u) ‚àà p.œÄ.ker := (h2pq u).trans hu,
    rw [q.update_apply _ hu, ‚Üê prod.zero_mk_add_zero_mk, map_add, p.update_ker_pi _ _ hup,
      ‚Üê prod.smul_zero_mk, map_smul, vadd_eq_add],
    nth_rewrite 0 [‚Üê sub_add_cancel (0, q.v) p.v],
    rw [map_add, p.update_ker_pi _ _ hv, p.update_v, bundle_snd_eq],
    refl },
  have := preimage_vadd_neg (show E', from œÉ.2 (p.v - (0, q.v)))
    (show set E', from (R.slice (bundle_snd œÉ) q)),
  dsimp only at this,
  simp_rw [‚Üê this, mem_preimage, mem_slice, R.mem_relativize],
  dsimp only [one_jet_bundle_mk_fst, one_jet_bundle_mk_snd],
  congr'
end

lemma relativize_slice_eq_univ {œÉ : one_jet_bundle (IP.prod I) (P √ó M) I' M'}
  {p : dual_pair' $ tangent_space (IP.prod I) œÉ.1.1}
  (hp : p.œÄ.comp (continuous_linear_map.inr ‚Ñù EP E) = 0) :
  ((R.relativize IP P).slice œÉ p).nonempty ‚Üî
  (R.relativize IP P).slice œÉ p = univ :=
begin
  have h2p : ‚àÄ x : E, p.œÄ ((0 : EP), x) = 0 := Œª x, congr_arg (Œª f : E ‚ÜíL[‚Ñù] ‚Ñù, f x) hp,
  have : ‚àÄ y : E', (p.update œÉ.snd y).comp (continuous_linear_map.inr ‚Ñù EP E) =
    œÉ.snd.comp (continuous_linear_map.inr ‚Ñù EP E),
  { intro y,
    ext1 x,
    simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
      p.update_ker_pi _ _ (h2p x)] },
  simp_rw [set.nonempty, eq_univ_iff_forall, mem_slice, R.mem_relativize],
  dsimp only [one_jet_bundle_mk_fst, one_jet_bundle_mk_snd],
  simp_rw [this, exists_const, forall_const]
end

variables (IP P)

lemma rel_mfld.ample.relativize (hR : R.ample) : (R.relativize IP P).ample :=
begin
  intros œÉ p,
  let p2 := p.œÄ.comp (continuous_linear_map.inr ‚Ñù EP E),
  rcases eq_or_ne p2 0 with h|h,
  { intros w hw,
    rw [(relativize_slice_eq_univ h).mp ‚ü®w, hw‚ü©, connected_component_in_univ,
      preconnected_space.connected_component_eq_univ, convex_hull_univ] },
  obtain ‚ü®u', hu'‚ü© := continuous_linear_map.exists_ne_zero h,
  let u := (p2 u')‚Åª¬π ‚Ä¢ u',
  let q : dual_pair' (tangent_space I œÉ.1.1.2) :=
  ‚ü®p2, u, by rw [p2.map_smul, smul_eq_mul, inv_mul_cancel hu']‚ü©,
  rw [relativize_slice q rfl],
  refine (hR q).vadd,
end

variables {IP P}

lemma family_one_jet_sec.uncurry_mem_relativize (S : family_one_jet_sec I M I' M' IP P) {s : P}
  {x : M} : S.uncurry (s, x) ‚àà R.relativize IP P ‚Üî S s x ‚àà R :=
begin
  simp_rw [rel_mfld.relativize, mem_preimage, bundle_snd_eq, one_jet_sec.coe_apply,
    map_left],
  congr',
  ext v,
  simp_rw [S.uncurry_œï', continuous_linear_map.comp_apply, continuous_linear_map.add_apply,
    continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
    continuous_linear_map.coe_fst', continuous_linear_map.coe_snd',
    continuous_linear_map.map_zero, zero_add, S.coe_œï]
end

def family_formal_sol.uncurry
  (S : family_formal_sol IP P R) : formal_sol (R.relativize IP P) :=
begin
  refine ‚ü®S.to_family_one_jet_sec.uncurry, _‚ü©,
  rintro ‚ü®s, x‚ü©,
  exact S.to_family_one_jet_sec.uncurry_mem_relativize.mpr (S.is_sol' s x)
end

lemma family_formal_sol.uncurry_œï' (S : family_formal_sol IP P R) (p : P √ó M) :
  S.uncurry.œï p = mfderiv IP I' (Œª z, S.bs z p.2) p.1 ‚àòL continuous_linear_map.fst ‚Ñù EP E +
  S.œï p.1 p.2 ‚àòL continuous_linear_map.snd ‚Ñù EP E :=
S.to_family_one_jet_sec.uncurry_œï' p

def family_one_jet_sec.curry (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N) :
  family_one_jet_sec I M I' M' (J.prod IP) (N √ó P) :=
{ bs := Œª p x, (S p.1).bs (p.2, x),
  œï := Œª p x, (S p.1).œï (p.2, x) ‚àòL mfderiv I (IP.prod I) (Œª x, (p.2, x)) x,
  smooth' := begin
    rintro ‚ü®‚ü®t, s‚ü©, x‚ü©,
    refine smooth_at_snd.one_jet_bundle_mk (S.smooth_bs.comp smooth_prod_assoc _) _,
    have h1 : smooth_at ((J.prod IP).prod I) ùìò(‚Ñù, EP √ó E ‚ÜíL[‚Ñù] E')
      (in_coordinates (IP.prod I) I' (Œª (p : (N √ó P) √ó M), (p.1.2, p.2))
        (Œª (p : (N √ó P) √ó M), (S p.1.1).bs (p.1.2, p.2))
        (Œª (p : (N √ó P) √ó M), ((S p.1.1).œï (p.1.2, p.2))) ((t, s), x)) ((t, s), x),
    { apply (smooth_at_one_jet_bundle.mp $
        smooth_at.comp _ (by exact S.smooth (t, (s, x))) (smooth_prod_assoc ((t, s), x))).2.2 },
    have h2 : smooth_at ((J.prod IP).prod I) ùìò(‚Ñù, E ‚ÜíL[‚Ñù] EP √ó E)
      (in_coordinates I (IP.prod I) prod.snd (Œª (p : (N √ó P) √ó M), (p.1.2, p.2))
        (Œª (p : (N √ó P) √ó M),
          (mfderiv I (IP.prod I) (Œª (x : M), (p.1.2, x)) p.2)) ((t, s), x)) ((t, s), x),
    { apply cont_mdiff_at.mfderiv''' (Œª (p : (N √ó P) √ó M) (x : M), (p.1.2, x)) prod.snd
        (smooth_at_fst.fst.snd.prod_mk smooth_at_snd :
          smooth_at (((J.prod IP).prod I).prod I) (IP.prod I) _ (((t, s), x), x))
        (smooth_at_snd : smooth_at ((J.prod IP).prod I) _ _ _) le_top },
    exact h1.clm_comp_in_coordinates (continuous_at_fst.snd.prod continuous_at_snd) h2
  end }

lemma family_one_jet_sec.curry_bs (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N) (p : N √ó P)
  (x : M) : (S.curry p).bs x = (S p.1).bs (p.2, x) :=
rfl

lemma family_one_jet_sec.curry_œï (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N) (p : N √ó P)
  (x : M) : (S.curry p).œï x = (S p.1).œï (p.2, x) ‚àòL mfderiv I (IP.prod I) (Œª x, (p.2, x)) x :=
rfl

lemma family_one_jet_sec.curry_œï' (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N) (p : N √ó P)
  (x : M) : (S.curry p).œï x = (S p.1).œï (p.2, x) ‚àòL continuous_linear_map.inr ‚Ñù EP E :=
begin
  rw [S.curry_œï],
  congr' 1,
  refine ((mdifferentiable_at_const I IP).mfderiv_prod smooth_id.mdifferentiable_at).trans _,
  rw [mfderiv_id, mfderiv_const],
  refl,
end

lemma formal_sol.eq_iff {F‚ÇÅ F‚ÇÇ : formal_sol R} {x : M} :
  F‚ÇÅ x = F‚ÇÇ x ‚Üî F‚ÇÅ.bs x = F‚ÇÇ.bs x ‚àß F‚ÇÅ.œï x = by apply F‚ÇÇ.œï x :=
by { simp_rw [sigma.ext_iff, formal_sol.fst_eq, heq_iff_eq, prod.ext_iff, eq_self_iff_true,
  true_and], refl }

lemma family_one_jet_sec.is_holonomic_at_curry
  (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N)
  {t : N} {s : P} {x : M} (hS : (S t).is_holonomic_at (s, x)) :
  (S.curry (t, s)).is_holonomic_at x :=
begin
  simp_rw [one_jet_sec.is_holonomic_at, (S.curry _).snd_eq, S.curry_œï] at hS ‚ä¢,
  dsimp only,
  rw [show (S.curry (t, s)).bs = Œª x, (S.curry (t, s)).bs x, from rfl, funext (S.curry_bs _)],
  dsimp only,
  refine (mfderiv_comp x (S t).smooth_bs.mdifferentiable_at
    ((mdifferentiable_at_const I IP).prod_mk smooth_id.mdifferentiable_at)).trans _,
  rw [id, hS],
  refl,
end

lemma family_one_jet_sec.curry_mem (S : family_one_jet_sec (IP.prod I) (P √ó M) I' M' J N)
  {p : N √ó P} {x : M} (hR : S p.1 (p.2, x) ‚àà R.relativize IP P) :
  S.curry p x ‚àà R :=
begin
  simp_rw [rel_mfld.relativize, mem_preimage, bundle_snd_eq, one_jet_sec.coe_apply,
    map_left] at hR ‚ä¢,
  convert hR,
  ext v,
  simp_rw [S.curry_œï']
end


def family_formal_sol.curry (S : family_formal_sol J N (R.relativize IP P)) :
  family_formal_sol (J.prod IP) (N √ó P) R :=
‚ü®S.to_family_one_jet_sec.curry, Œª p x, S.to_family_one_jet_sec.curry_mem S.is_sol‚ü©

lemma family_formal_sol.curry_œï (S : family_formal_sol J N (R.relativize IP P)) (p : N √ó P)
  (x : M) : (S.curry p).œï x = (S p.1).œï (p.2, x) ‚àòL mfderiv I (IP.prod I) (Œª x, (p.2, x)) x :=
rfl

lemma family_formal_sol.curry_œï' (S : family_formal_sol J N (R.relativize IP P)) (p : N √ó P)
  (x : M) : (S.curry p).œï x = (S p.1).œï (p.2, x) ‚àòL continuous_linear_map.inr ‚Ñù EP E :=
S.to_family_one_jet_sec.curry_œï' p x

lemma curry_eq_iff_eq_uncurry {ùìï : family_formal_sol J N (R.relativize IP P)}
  {ùìï‚ÇÄ : family_formal_sol IP P R} {t : N} {x : M} {s : P}
  (h : ùìï t (s, x) = ùìï‚ÇÄ.uncurry (s, x)) :
  (ùìï.curry (t, s)) x = ùìï‚ÇÄ s x :=
begin
  simp_rw [formal_sol.eq_iff] at h ‚ä¢,
  refine ‚ü®h.1, _‚ü©,
  simp_rw [ùìï.curry_œï', h.2, ùìï‚ÇÄ.uncurry_œï'],
  ext v,
  simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.add_apply,
    continuous_linear_map.comp_apply,
    continuous_linear_map.inr_apply, continuous_linear_map.coe_fst',
    continuous_linear_map.coe_snd', continuous_linear_map.map_zero, zero_add],
  refl
end

lemma rel_mfld.satisfies_h_principle.satisfies_h_principle_with
  (R : rel_mfld I M IX X) {C : set (P √ó M)}
  (Œµ : M ‚Üí ‚Ñù) (h : (R.relativize IP P).satisfies_h_principle C (Œª x, Œµ x.2)) :
  R.satisfies_h_principle_with IP C Œµ :=
begin
  intros ùìï‚ÇÄ hùìï‚ÇÄ,
  obtain ‚ü®ùìï, h1ùìï, h2ùìï, h3ùìï, h4ùìï‚ü© :=
    h ùìï‚ÇÄ.uncurry (hùìï‚ÇÄ.mono (Œª p hp, ùìï‚ÇÄ.to_family_one_jet_sec.is_holonomic_uncurry.mpr hp)),
  refine ‚ü®ùìï.curry, _, _, _, _‚ü©,
  { intros s x, exact curry_eq_iff_eq_uncurry (h1ùìï (s, x)) },
  { intros s x, exact ùìï.to_family_one_jet_sec.is_holonomic_at_curry (h2ùìï (s, x)) },
  { refine h3ùìï.mono _, rintro ‚ü®s, x‚ü© hp t, exact curry_eq_iff_eq_uncurry (hp t) },
  { intros t s x, exact (h4ùìï t (s, x)) },
end

end parameter_space
