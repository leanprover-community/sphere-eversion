import tactic.linarith
import algebra.order.with_zero
import topology.locally_finite
import data.fin.interval
import data.fin.succ_pred

import to_mathlib.set_theory.cardinal.basic

/-!
# Indexing types

This is a stupid file introducing a type class for types that will index
locally finite covers of (paracompact) manifolds without having
to discuss according to compactness. The only intended instances
are `‚Ñï` and `fin (n+1)`.

It also includes a lemma about locally finite cover that doesn't require an indexing
index type but will be used with one.
-/

open set

class indexing (Œ± : Type*) [linear_order Œ±] :=
(from_nat : ‚Ñï ‚Üí Œ±)
(to_nat : Œ± ‚Üí ‚Ñï)
(mono_from : monotone from_nat)
(from_to : ‚àÄ a, from_nat (to_nat a) = a)

instance indexing.has_coe (Œ± : Type*) [linear_order Œ±] [indexing Œ±] : has_coe ‚Ñï Œ± :=
‚ü®indexing.from_nat‚ü©

@[simp]
lemma indexing.coe_to {Œ± : Type*} [linear_order Œ±] [indexing Œ±] (i : Œ±) :
  ((indexing.to_nat i) : Œ±) = i :=
indexing.from_to i

lemma indexing.coe_mono {Œ± : Type*} [linear_order Œ±] [indexing Œ±] {i j : ‚Ñï} (h : i ‚â§ j) :
  (i : Œ±) ‚â§ j :=
indexing.mono_from h

instance indexing.nonempty (Œ± : Type*) [linear_order Œ±] [indexing Œ±] : nonempty Œ± :=
‚ü®indexing.from_nat 0‚ü©

instance : indexing ‚Ñï :=
{ from_nat := id,
  to_nat := id,
  mono_from := monotone_id,
  from_to := Œª n, rfl }

instance (n : ‚Ñï) : indexing (fin $ n + 1) :=
{ from_nat := Œª k, if h : k < n + 1 then ‚ü®k, h‚ü© else fin.last n,
  to_nat := coe,
  mono_from := Œª k l hkl, begin
    dsimp [fin.of_nat],
    split_ifs ; try { simp [fin.le_last] };
    linarith,
  end,
  from_to := begin
    rintros ‚ü®k, hk‚ü©,
    erw dif_pos hk,
    refl
  end }

open_locale topological_space

/-- Our model indexing type depending on `n : ‚Ñï` is `‚Ñï` if `n = 0` and `fin n` otherwise-/
def index_type (n : ‚Ñï) : Type :=
nat.cases_on n ‚Ñï (Œª k, fin $ k + 1)

@[simp] lemma index_type_zero : index_type 0 = ‚Ñï := rfl

@[simp] lemma index_type_succ (n : ‚Ñï) : index_type (n + 1) = fin (n + 1) := rfl

@[simp] lemma index_type_of_zero_lt {n : ‚Ñï} (h : 0 < n) : index_type n = fin n :=
by rw [‚Üê nat.succ_pred_eq_of_pos h, index_type_succ]

instance (n : ‚Ñï) : linear_order (index_type n) :=
nat.cases_on n nat.linear_order (Œª _, fin.linear_order)

instance (n : ‚Ñï) : indexing (index_type n) :=
nat.cases_on n nat.indexing (Œª _, fin.indexing _)

instance (n : ‚Ñï) : locally_finite_order (index_type n) :=
nat.cases_on n nat.locally_finite_order (Œª _, fin.locally_finite_order _)

instance (n : ‚Ñï) : order_bot (index_type n) :=
nat.cases_on n nat.order_bot (Œª k, show order_bot $ fin (k + 1), by apply_instance)

instance (n : ‚Ñï) : succ_order (index_type n) :=
nat.cases_on n nat.succ_order (Œª k, fin.succ_order)

def index_from_nat (N n : ‚Ñï) : index_type N := indexing.from_nat n

instance (N : ‚Ñï) : has_zero (index_type N) := ‚ü®indexing.from_nat 0‚ü©

lemma index_from_nat_zero (N : ‚Ñï) : index_from_nat N 0 = 0 :=
rfl

protected lemma index_type.Iic_zero (n : ‚Ñï) : Iic (0 : index_type n) = {0} :=
nat.cases_on n (by { ext n, simp [@le_zero_iff ‚Ñï] }) (Œª k, by { ext n, simp })

@[simp] lemma fin.coe_order_succ {n : ‚Ñï} (a : fin (n+1)) :
  ((order.succ a : fin _) : ‚Ñï) = if (a : ‚Ñï) < n then a + 1 else a :=
begin
  simp_rw [order.succ, fin.succ_eq],
  split_ifs,
  { simp_rw [fin.coe_add_one_of_lt h] },
  { refl }
end

@[simp] lemma fin.coe_order_succ_mk {n m : ‚Ñï} (h : m < n + 1) :
  ((order.succ ‚ü®m, h‚ü© : fin _) : ‚Ñï) = if m < n then m + 1 else m := fin.coe_order_succ _

protected lemma index_from_nat_succ (N m : ‚Ñï) : index_from_nat N (m + 1) =
  order.succ (index_from_nat N m) :=
begin
  refine nat.cases_on N rfl (Œª n, _),
  dsimp only [index_from_nat, index_type, index_type.indexing, fin.indexing, index_type.succ_order],
  ext,
  split_ifs with h h' h',
  { rw [fin.coe_order_succ_mk, if_pos (nat.lt_of_succ_lt_succ h)], refl },
  { linarith },
  { obtain rfl : m = n :=
      le_antisymm (nat.le_of_lt_succ h') (nat.le_of_succ_le_succ $ le_of_not_lt h),
    rw [fin.coe_order_succ_mk, if_neg (lt_irrefl _)], refl },
  { rw [fin.coe_order_succ, fin.coe_last, if_neg (lt_irrefl _)] }
end

lemma set.countable_iff_exists_nonempty_index_type_equiv
  {Œ± : Type*} {s : set Œ±} (hne : s.nonempty) :
  s.countable ‚Üî ‚àÉ n, nonempty (index_type n ‚âÉ s) :=
begin
  -- Huge golfing opportunity.
  cases @set.finite_or_infinite _ s,
  { refine ‚ü®Œª hh, ‚ü®h.to_finset.card, _‚ü©, Œª _, h.countable‚ü©,
    have : 0 < h.to_finset.card,
    { rw finset.card_pos, exact (set.finite.nonempty_to_finset h).mpr hne},
    simp only [this, index_type_of_zero_lt],
    have e‚ÇÅ := fintype.equiv_fin h.to_finset,
    rw [fintype.card_coe, h.coe_sort_to_finset] at e‚ÇÅ,
    exact ‚ü®e‚ÇÅ.symm‚ü©, },
  { refine ‚ü®Œª hh, ‚ü®0, _‚ü©, _‚ü©,
    { simp only [index_type_zero],
      obtain ‚ü®_i‚ü© := set.countable_infinite_iff_nonempty_denumerable.mp ‚ü®hh, h‚ü©,
      haveI := _i,
      exact ‚ü®(denumerable.eqv s).symm‚ü©, },
    { rintros ‚ü®n, ‚ü®fn‚ü©‚ü©,
      have hn : n = 0,
      { by_contra hn,
        replace hn : 0 < n := zero_lt_iff.mpr hn,
        simp only [hn, index_type_of_zero_lt] at fn,
        exact set.not_infinite.mpr ‚ü®fintype.of_equiv (fin n) fn‚ü© h, },
      simp only [hn, index_type_zero] at fn,
      exact set.countable_iff_exists_injective.mpr ‚ü®fn.symm, fn.symm.injective‚ü©, }, },
end

open filter

/-
Old statement assumed h : ‚àÄ n, {x : X | f (n + 1) x ‚â† f n x} ‚äÜ V (n + 1 : ‚Ñï)
which gives the new style assumption by:
  replace h : ‚àÄ n : ‚Ñï, ‚àÄ x ‚àâ V (n + 1 : ‚Ñï), f (n+1) x = f n x,
  { intros n x hx,
    contrapose hx,
    simp [h n hx] },
-/

lemma locally_finite.exists_forall_eventually_of_indexing
  {Œ± X Œπ : Type*} [topological_space X] [linear_order Œπ] [indexing Œπ] {f : ‚Ñï ‚Üí X ‚Üí Œ±}
  {V : Œπ ‚Üí set X} (hV : locally_finite V)
  (h : ‚àÄ n : ‚Ñï, ‚àÄ x ‚àâ V ((n + 1) : ‚Ñï), f (n + 1) x = f n x)
  (h' : ‚àÄ n : ‚Ñï, ((n+1 : ‚Ñï) : Œπ) = n ‚Üí f (n + 1) = f n) :
  ‚àÉ (F : X ‚Üí Œ±), ‚àÄ (x : X), ‚àÄ·∂† (n : ‚Ñï) in filter.at_top, f n =·∂†[ùìù x] F :=
begin
  let œÄ :  ‚Ñï ‚Üí Œπ := indexing.from_nat,
  choose U hUx hU using hV,
  choose i‚ÇÄ hi‚ÇÄ using Œª x, (hU x).bdd_above,
  let n‚ÇÄ : X ‚Üí ‚Ñï := indexing.to_nat ‚àò i‚ÇÄ,
  have key : ‚àÄ {x} {n}, n ‚â• n‚ÇÄ x ‚Üí ‚àÄ {y}, y ‚àà U x ‚Üí f n y = f (n‚ÇÄ x) y,
  { intros x n hn,
    rcases le_iff_exists_add.mp hn with ‚ü®k, rfl‚ü©, clear hn,
    intros y hy,
    induction k with k hk,
    { simp },
    { rw ‚Üê hk, clear hk,
      have : ‚àÄ n, œÄ n < œÄ (n+1) ‚à® œÄ n = œÄ (n+1),
      exact Œª n, lt_or_eq_of_le (indexing.mono_from n.le_succ),
      rcases this (n‚ÇÄ x + k) with H | H ; clear this,
      { have ineq : œÄ (n‚ÇÄ x + k + 1) > i‚ÇÄ x,
        { suffices : i‚ÇÄ x ‚â§ œÄ (n‚ÇÄ x + k), from lt_of_le_of_lt this H,
          rw ‚Üê indexing.from_to (i‚ÇÄ x),
          exact indexing.mono_from le_self_add },
        apply h,
        rintro (hy' : y ‚àà V (œÄ (n‚ÇÄ x + k + 1))),
        have := hi‚ÇÄ x ‚ü®y, ‚ü®hy', hy‚ü©‚ü©, clear hy hy',
        exact lt_irrefl _ (lt_of_le_of_lt this ineq) },
      { erw [‚Üê (h' _ H.symm)],
        refl } } },
  refine ‚ü®Œª x, f (n‚ÇÄ x) x, Œª x, _‚ü©,
  change ‚àÄ·∂† (n : ‚Ñï) in at_top, f n =·∂†[ùìù x] Œª (y : X), f (n‚ÇÄ y) y,
  apply (eventually_gt_at_top (n‚ÇÄ x)).mono (Œª n hn, _),
  apply mem_of_superset (hUx x) (Œª y hy, _),
  change f n y = f (n‚ÇÄ y) y,
  calc f n y = f (n‚ÇÄ x) y : key hn.le hy
  ... = f (max (n‚ÇÄ x) (n‚ÇÄ y)) y : (key (le_max_left _ _) hy).symm
  ... = f (n‚ÇÄ y) y : key (le_max_right _ _) (mem_of_mem_nhds $ hUx y)
end

lemma index_type.lt_or_eq_succ (N n : ‚Ñï) :
  (n : index_type N) < (n+1 : ‚Ñï) ‚à® (n : index_type N) = (n+1 : ‚Ñï) :=
begin
  rw or_comm,
  exact eq_or_lt_of_le (indexing.mono_from n.le_succ)
end

lemma index_type.le_or_lt_succ {N n : ‚Ñï} (hn : (n : index_type N) < (n+1 : ‚Ñï)) (j : index_type N) :
  j ‚â§ n ‚Üî j < (n + 1 : ‚Ñï) :=
begin
  cases N, { exact nat.lt_succ_iff.symm, },
  refine ‚ü®Œª h, lt_of_le_of_lt h hn, Œª h, _‚ü©,
  clear hn,
  obtain ‚ü®j, hj‚ü© := j,
  change _ ‚â§ indexing.from_nat n,
  change _ < indexing.from_nat (n + 1) at h,
  unfold indexing.from_nat at ‚ä¢ h,
  rcases lt_trichotomy N n with hNn | rfl | hNn,
  { replace hNn : ¬¨ (n < N + 1) := by simpa using nat.succ_le_iff.mpr hNn,
    simp only [hNn, not_false_iff, dif_neg],
    exact fin.le_last _ },
  { simpa using nat.lt_succ_iff.mp hj },
  { simp only [hNn, add_lt_add_iff_right, dif_pos, fin.mk_lt_mk] at h,
    simpa only [nat.lt.step hNn, dif_pos, fin.mk_le_mk] using nat.lt_succ_iff.mp h }
end

lemma index_type.tendsto_coe_at_top (N : ‚Ñï) : tendsto (coe : ‚Ñï ‚Üí index_type N) at_top at_top :=
tendsto_at_top_at_top.mpr
  (Œª i, ‚ü®indexing.to_nat i, Œª n hn,(indexing.from_to i) ‚ñ∏ indexing.coe_mono hn‚ü©)

lemma index_type.not_lt_zero {N : ‚Ñï} (j : index_type N) : ¬¨ (j < 0) :=
nat.cases_on N nat.not_lt_zero (Œª n, fin.not_lt_zero) j
