import loops.basic
import data.real.pi
import tactic.fin_cases
/-!
# Surrounding families of loops
-/

open set function finite_dimensional
open_locale topological_space

variables {E : Type*} [normed_group E] [normed_space ‚Ñù E]
          {F : Type*} [normed_group F] [normed_space ‚Ñù F] [finite_dimensional ‚Ñù F]

local notation `d` := findim ‚Ñù F
local notation `smooth_on` := times_cont_diff_on ‚Ñù ‚ä§
local notation `I` := Icc (0 : ‚Ñù) 1

/-- A loop `Œ≥` surrounds a point `x` if `x` is surrounded by values of `Œ≥`. -/
def loop.surrounds (Œ≥ : loop F) (x : F) : Prop := 
  ‚àÉ t w : fin (d + 1) ‚Üí ‚Ñù, surrounding_pts x (Œ≥ ‚àò t) w

lemma loop.surrounds_iff_range_subset_range (Œ≥ : loop F) (x : F) : 
  Œ≥.surrounds x ‚Üî ‚àÉ (p : fin (d + 1) ‚Üí F) (w : fin (d + 1) ‚Üí ‚Ñù), 
  surrounding_pts x p w ‚àß range p ‚äÜ range Œ≥ :=
begin
  split,
  { exact Œª ‚ü®t, w, h‚ü©, ‚ü®(Œ≥ ‚àò t), w, h, range_comp_subset_range _ _‚ü© },
  { rintros ‚ü®p, w, h‚ÇÄ, h‚ÇÅ‚ü©,
    rw range_subset_iff at h‚ÇÅ,
    choose t ht using h‚ÇÅ,
    have hpt : Œ≥ ‚àò t = p := funext ht,
    exact ‚ü®t, w, hpt.symm ‚ñ∏ h‚ÇÄ‚ü© }
end

/- Slower and less clear... I guess ?
lemma surrounding_loop_of_convex_hull2 {f b : F} {O : set F} (O_op : is_open O) (O_conn : is_connected O) 
  (hsf : f ‚àà convex_hull O) (hb : b ‚àà O) : 
  ‚àÉ Œ≥ : ‚Ñù ‚Üí loop F, continuous_on ‚ÜøŒ≥ (set.prod I univ) ‚àß 
                    (‚àÄ t, Œ≥ t 0 = b) ‚àß
                    (‚àÄ s, Œ≥ 0 s = b) ‚àß
                    (‚àÄ (t ‚àà I) s, Œ≥ t s ‚àà O) ‚àß
                    (Œ≥ 1).surrounds f :=
begin
  rcases surrounded_of_convex_hull O_op hsf with ‚ü®p, w, h, hp‚ü©,
  rw ‚Üê O_op.is_connected_iff_is_path_connected at O_conn,
  rcases (O_conn.exists_path_through_family' p hp) with ‚ü®Œ©‚ÇÄ, t, hŒ©‚ÇÄ‚ü©,
  rcases O_conn.joined_in b (p 0) hb (hp 0) with ‚ü®Œ©‚ÇÅ, hŒ©‚ÇÅ‚ü©,
  let Œ© := Œ©‚ÇÅ.trans Œ©‚ÇÄ,
  let Œ≥ : ‚Ñù ‚Üí loop F := Œª t, let t' := proj_I t in
  { to_fun :=
      (Œª s' : ‚Ñù, if s'‚â§t' then Œ©.extend s' else Œ©.extend t') ‚àò (Œª s, (1 - real.cos (2*real.pi*s))/2),
    per' :=
    begin
      intros s,
      suffices h : (Œª s, (1 - real.cos (2*real.pi*s))/2) (s+1) = (Œª s, (1 - real.cos (2*real.pi*s))/2) s,
      { delta function.comp,
        rw h },
      simp only [mul_add, mul_one, real.cos_add_two_pi],
    end },
  use Œ≥,
  split,
  { apply continuous.continuous_on,
    have h‚ÇÅ : continuous (Œª (s : ‚Ñù √ó ‚Ñù), (1 - real.cos (2 * real.pi * s.snd)) / 2) :=
      (continuous_mul_right _).comp ((continuous_const.sub continuous_id).comp $ 
        real.continuous_cos.comp $ (continuous_mul_left _).comp continuous_snd),
    have h‚ÇÇ : continuous (Œª (a : ‚Ñù √ó ‚Ñù), ‚Üë(proj_I a.fst)) :=
      continuous_subtype_coe.comp (continuous_proj_I.comp continuous_fst),
    simp only [Œ≥, has_uncurry.uncurry, coe_fn, has_coe_to_fun.coe, mul_one, comp_app],
    refine continuous_if _ (Œ©.continuous_extend.comp h‚ÇÅ) (Œ©.continuous_extend.comp h‚ÇÇ),
    rintros ‚ü®a, b‚ü© hab,
    have := frontier_le_subset_eq h‚ÇÅ h‚ÇÇ hab,
    simp only [mem_set_of_eq] at this,
    rw this },
  split,
  { unfold_coes,
    intros t,
    simp [Œ≥, ‚Üê subtype.val_eq_coe, (proj_I t).2.1] },
  split,
  { unfold_coes,
    intros s,
    simp only [Œ≥, proj_I, dif_pos, path.extend_zero, comp_app, subtype.coe_mk],
    split_ifs with h,
    { have : real.cos (2 * real.pi * s) = 1 := le_antisymm (real.cos_le_one _) (by linarith [h]),
      simp only [this, path.extend_zero, zero_div, sub_self] },
    { refl } },
  split,
  { have : ‚àÄ t, Œ©.extend t ‚àà O,
    { rw ‚Üê range_subset_iff,
      simp [Œ©.extend_range, Œ©‚ÇÅ.trans_range, range_subset_iff.mpr hŒ©‚ÇÄ.left, range_subset_iff.mpr hŒ©‚ÇÅ] },
    rintros t ‚ü®ht‚ÇÄ, ht‚ÇÅ‚ü© s,
    simp only [has_coe_to_fun.coe, coe_fn, Œ≥],
    rw [comp_app, ‚Üê apply_ite],
    refine this _ },
  { use [(Œª i, (2*real.pi)‚Åª¬π * (real.arccos (- t i))), w],
    simp only [has_coe_to_fun.coe, coe_fn, Œ≥, comp],
    convert h,
    ext i,
    have hproj : (proj_I 1 : ‚Ñù) = 1,
    { simp [proj_I, not_le_of_lt zero_lt_one, le_refl 1] },
    have hmem : (1 + (t i : ‚Ñù))/2 ‚àà (Icc (1/2) 1 : set ‚Ñù),
    { split; unfold_coes; linarith [(t i).2.1, (t i).2.2] },
    have hmem' : (1 + (t i : ‚Ñù))/2 ‚àà (Icc 0 1 : set ‚Ñù),
    { split; [linarith [hmem.1], exact hmem.2] },
    rw [hproj, Œ©.extend_one, mul_inv_cancel_left', real.cos_arccos, sub_neg_eq_add,
        Œ©.extend_extends hmem'],
    simp only [has_coe_to_fun.coe, coe_fn, eq_true_intro hmem.2, Œ©, if_true, path.trans, comp_app],
    split_ifs with h',
    { have : t i = 0,
      { have : (1 + (t i : ‚Ñù))/2 = 1/2 := le_antisymm h' hmem.1,
        rw div_eq_div_iff at this,
        { rw [subtype.ext_iff, coe_I_zero], 
          linarith },
        { norm_num },
        { norm_num } },
      have key := hŒ©‚ÇÄ.2 i,
      rw [this, path.source] at key,
      simpa [this, @mul_inv_cancel _ _ (2 : ‚Ñù) two_ne_zero] },
    { convert hŒ©‚ÇÄ.2 i,
      rw ‚Üê Œ©‚ÇÄ.extend_extends',
      congr,
      unfold_coes,
      field_simp,
      ring },
    all_goals {try {unfold_coes}, linarith [(t i).2.2, (t i).2.1, real.pi_pos]} }
end
-/

lemma surrounding_loop_of_convex_hull {f b : F} {O : set F} (O_op : is_open O) (O_conn : is_connected O) 
  (hsf : f ‚àà convex_hull O) (hb : b ‚àà O) : 
  ‚àÉ Œ≥ : ‚Ñù ‚Üí loop F, continuous_on ‚ÜøŒ≥ (set.prod I univ) ‚àß 
                    (‚àÄ t, Œ≥ t 0 = b) ‚àß
                    (‚àÄ s, Œ≥ 0 s = b) ‚àß
                    (‚àÄ (t ‚àà I) s, Œ≥ t s ‚àà O) ‚àß
                    (Œ≥ 1).surrounds f :=
begin
  rcases surrounded_of_convex_hull O_op hsf with ‚ü®p, w, h, hp‚ü©,
  rw ‚Üê O_op.is_connected_iff_is_path_connected at O_conn,
  rcases (O_conn.exists_path_through_family p hp) with ‚ü®Œ©‚ÇÄ, hŒ©‚ÇÄ‚ü©,
  rcases O_conn.joined_in b (p 0) hb (hp 0) with ‚ü®Œ©‚ÇÅ, hŒ©‚ÇÅ‚ü©,
  let Œ© := Œ©‚ÇÅ.trans Œ©‚ÇÄ,
  let Œ≥ : ‚Ñù ‚Üí loop F := Œª t, let t' := proj_I t in
  { to_fun :=
      (Œª s' : ‚Ñù, if s'‚â§t' then Œ©.extend s' else Œ©.extend t') ‚àò (Œª s, (1 - real.cos (2*real.pi*s))/2),
    per' :=
    begin
      intros s,
      suffices h : (Œª s, (1 - real.cos (2*real.pi*s))/2) (s+1) = (Œª s, (1 - real.cos (2*real.pi*s))/2) s,
      { delta function.comp,
        rw h },
      simp only [mul_add, mul_one, real.cos_add_two_pi],
    end },
  refine ‚ü®Œ≥, _, _, _, _, _‚ü©,
  { apply continuous.continuous_on,
    have h‚ÇÅ : continuous (Œª (s : ‚Ñù √ó ‚Ñù), (1 - real.cos (2 * real.pi * s.snd)) / 2) :=
      (continuous_mul_right _).comp ((continuous_const.sub continuous_id).comp $ 
        real.continuous_cos.comp $ (continuous_mul_left _).comp continuous_snd),
    have h‚ÇÇ : continuous (Œª (a : ‚Ñù √ó ‚Ñù), ‚Üë(proj_I a.fst)) :=
      continuous_subtype_coe.comp (continuous_proj_I.comp continuous_fst),
    simp only [Œ≥, has_uncurry.uncurry, coe_fn, has_coe_to_fun.coe, mul_one, comp_app],
    refine continuous_if _ (Œ©.continuous_extend.comp h‚ÇÅ) (Œ©.continuous_extend.comp h‚ÇÇ),
    rintros ‚ü®a, b‚ü© hab,
    have := frontier_le_subset_eq h‚ÇÅ h‚ÇÇ hab,
    simp only [mem_set_of_eq] at this,
    rw this },
  { intros t,
    simp [Œ≥, has_coe_to_fun.coe, coe_fn, ‚Üê subtype.val_eq_coe, (proj_I t).2.1] },
  { unfold_coes,
    intros s,
    simp only [Œ≥, proj_I, dif_pos, path.extend_zero, comp_app, subtype.coe_mk],
    split_ifs with h,
    { have : real.cos (2 * real.pi * s) = 1 := le_antisymm (real.cos_le_one _) (by linarith [h]),
      simp only [this, path.extend_zero, zero_div, sub_self]},
    { refl } },
  { rintros t ‚ü®ht‚ÇÄ, ht‚ÇÅ‚ü© s,
    simp only [has_coe_to_fun.coe, coe_fn, Œ≥],
    rw [comp_app, ‚Üê apply_ite],
    have : ‚àÄ t, Œ©.extend t ‚àà O,
    { rwa [‚Üê range_subset_iff, Œ©.extend_range, Œ©‚ÇÅ.trans_range, union_subset_iff, 
            eq_true_intro hŒ©‚ÇÄ.right, and_true, range_subset_iff] },
    refine this _ },
  { rw loop.surrounds_iff_range_subset_range,
    refine ‚ü®p, w, h, _‚ü©,
    rw range_subset_iff,
    intro i,
    unfold_coes,
    suffices h : p i ‚àà range Œ©.extend, 
    { have hproj : (proj_I 1 : ‚Ñù) = 1,
      { simp [proj_I, not_le_of_lt zero_lt_one, le_refl 1] },
      have hcos : I ‚äÜ range (Œª (s : ‚Ñù), (1 - real.cos (2 * real.pi * s)) / 2),
      { rintros x ‚ü®h‚ÇÄ, h‚ÇÅ‚ü©,
        rw mem_range,
        rcases @real.exists_cos_eq (1-2*x) ‚ü®by linarith, by linarith‚ü© with ‚ü®y, ‚ü®hy‚ÇÄ, hy‚ÇÅ‚ü©, hxy‚ü©,
        use (2*real.pi)‚Åª¬π * y,
        rw mul_inv_cancel_left';
        linarith [real.pi_pos] },
      simp only [Œ≥, range_comp, hproj, mem_image, path.extend_one],
      rcases h with ‚ü®x, hx‚ü©,
      use [proj_I x, hcos (proj_I x).2],
      have : (proj_I x : ‚Ñù) ‚àà I := (proj_I x).2,
      simpa only [this.right, Œ©.extend_extends this, if_true, subtype.coe_eta], },
    simp only [Œ©.extend_range, Œ©, path.trans_range],
    right,
    exact hŒ©‚ÇÄ.1 i }
end

structure surrounding_family (g b : E ‚Üí F) (Œ≥ : E ‚Üí ‚Ñù ‚Üí loop F) (U : set E) : Prop :=
(base : ‚àÄ x t, Œ≥ x t 0 = b x)
(t‚ÇÄ : ‚àÄ x s, Œ≥ x 0 s = b x)
(surrounds : ‚àÄ x, (Œ≥ x 1).surrounds $ g x)
(cont : continuous ‚ÜøŒ≥)

structure surrounding_family_in (g b : E ‚Üí F) (Œ≥ : E ‚Üí ‚Ñù ‚Üí loop F) (U : set E) (Œ© : set $E √ó F) 
  extends surrounding_family g b Œ≥ U : Prop :=
(val_in : ‚àÄ x ‚àà U, ‚àÄ (t ‚àà I) s, (x, Œ≥ x t s) ‚àà Œ©)

variables {g b : E ‚Üí F} {Œ© : set (E √ó F)} {U K : set E}

lemma local_loops
  {x‚ÇÄ : E}
  (hŒ©_op : ‚àÄ·∂† x in ùìù x‚ÇÄ, is_open (prod.mk x ‚Åª¬π' Œ©)) 
  (hg : ‚àÄ·∂† x in ùìù x‚ÇÄ, continuous_at g x) (hb : ‚àÄ·∂† x in ùìù x‚ÇÄ, continuous_at b x)
  (hb_in : ‚àÄ·∂† x in ùìù x‚ÇÄ, (x, b x) ‚àà Œ©) 
  (hconv : ‚àÄ·∂† x in ùìù x‚ÇÄ, g x ‚àà convex_hull (prod.mk x ‚Åª¬π' Œ©)) :
‚àÉ Œ≥ : E ‚Üí ‚Ñù ‚Üí loop F, ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ (t ‚àà I) s, 
  (x, Œ≥ x t s) ‚àà Œ© ‚àß
  Œ≥ x 0 s = b x ‚àß
  (Œ≥ x 1).surrounds (g x) ‚àß
  continuous_at ‚ÜøŒ≥ ((x, t, s) : E √ó ‚Ñù √ó ‚Ñù) :=
sorry


lemma satisfied_or_refund {Œ≥‚ÇÄ Œ≥‚ÇÅ : E ‚Üí ‚Ñù ‚Üí loop F} 
  (h‚ÇÄ : surrounding_family g b Œ≥‚ÇÄ U) (h‚ÇÅ : surrounding_family g b Œ≥‚ÇÅ U) :
  ‚àÉ Œ≥ : ‚Ñù ‚Üí E ‚Üí ‚Ñù ‚Üí loop F, 
    (‚àÄ œÑ ‚àà I, surrounding_family g b (Œ≥ œÑ) U) ‚àß 
    Œ≥ 0 = Œ≥‚ÇÄ ‚àß
    Œ≥ 1 = Œ≥‚ÇÅ ‚àß
    (‚àÄ (œÑ ‚àà I) (x ‚àà U) (t ‚àà I) s, continuous_at ‚ÜøŒ≥ (œÑ, x, t, s)) :=
sorry

lemma extends_loops {U‚ÇÄ U‚ÇÅ K‚ÇÄ K‚ÇÅ : set E} (hU‚ÇÄ : is_open U‚ÇÄ) (hU‚ÇÅ : is_open U‚ÇÅ)
  (hK‚ÇÄ : compact K‚ÇÄ) (hK‚ÇÅ : compact K‚ÇÅ) (hKU‚ÇÄ : K‚ÇÄ ‚äÜ U‚ÇÄ) (hKU‚ÇÅ : K‚ÇÅ ‚äÜ U‚ÇÅ)
  {Œ≥‚ÇÄ Œ≥‚ÇÅ : E ‚Üí ‚Ñù ‚Üí loop F} 
  (h‚ÇÄ : surrounding_family g b Œ≥‚ÇÄ U‚ÇÄ) (h‚ÇÅ : surrounding_family g b Œ≥‚ÇÅ U‚ÇÅ) :
  ‚àÉ U ‚àà nhds_set (K‚ÇÄ ‚à™ K‚ÇÅ), ‚àÉ Œ≥ : E ‚Üí ‚Ñù ‚Üí loop F, 
    surrounding_family g b Œ≥ U ‚àß 
    ‚àÄ·∂† x in nhds_set K‚ÇÄ, Œ≥ x = Œ≥‚ÇÄ x :=
sorry


lemma exists_surrounding_loops 
  (hU : is_open U) (hK : compact K) (hKU : K ‚äÜ U) 
  (hŒ©_op : ‚àÄ x ‚àà U, is_open (prod.mk x ‚Åª¬π' Œ©))
  (hŒ©_conn : ‚àÄ x ‚àà U, is_connected (prod.mk x ‚Åª¬π' Œ©)) 
  (hg : ‚àÄ x ‚àà U, smooth_at g x) (hb : ‚àÄ x ‚àà U, smooth_at b x) (hb_in : ‚àÄ x ‚àà U, (x, b x) ‚àà Œ©) 
  (hgK : ‚àÄ·∂† x in nhds_set K, g x = b x) 
  (hconv : ‚àÄ x ‚àà U, g x ‚àà convex_hull (prod.mk x ‚Åª¬π' Œ©)) 
  {Œ≥‚ÇÄ :  E ‚Üí ‚Ñù ‚Üí loop F} 
  (hŒ≥‚ÇÄ_surr : ‚àÉ V ‚àà nhds_set K, surrounding_family_in g b Œ≥‚ÇÄ V Œ©) :
  ‚àÉ Œ≥ : E ‚Üí ‚Ñù ‚Üí loop F, (surrounding_family_in g b Œ≥ U Œ©) ‚àß 
                        (‚àÄ·∂† x in nhds_set K, ‚àÄ (t ‚àà I), Œ≥ x t = Œ≥‚ÇÄ x t)  :=
sorry