import local.h_principle
-- import global.parametricity_for_free -- remove!?
import interactive_expr

set_option trace.filter_inst_type true

/-!
This is a stop-gap file to prove the parametric local h-principle.
-/
noncomputable theory

open metric finite_dimensional set function rel_loc
open_locale topological_space

section parameter_space

variables
{E : Type*} [normed_add_comm_group E] [normed_space ‚Ñù E]
{F : Type*} [normed_add_comm_group F] [normed_space ‚Ñù F]
{G : Type*} [normed_add_comm_group G] [normed_space ‚Ñù G] -- this will be ‚Ñù in the application
{P : Type*} [normed_add_comm_group P] [normed_space ‚Ñù P]


variables {R : rel_loc E F}

def one_jet_snd : one_jet (P √ó E) F ‚Üí one_jet E F :=
Œª p, (p.1.2, p.2.1, p.2.2 ‚àòL fderiv ‚Ñù (Œª y, (p.1.1, y)) p.1.2)

lemma continuous_one_jet_snd :
  continuous (one_jet_snd : one_jet (P √ó E) F ‚Üí one_jet E F) :=
begin
  sorry
  -- intro x‚ÇÄ,
  -- refine smooth_at.map_left _ _ smooth_at_id,
  -- { exact smooth_at_snd.snd },
  -- have := cont_mdiff_at.mfderiv'''
  --   (Œª (x : one_jet_bundle (J.prod I) (P √ó E) I' E') (y : E), (x.1.1.1, y))
  --   (Œª (x : one_jet_bundle (J.prod I) (P √ó E) I' E'), x.1.1.2)
  --   (smooth_one_jet_bundle_proj.fst.fst.prod_map smooth_id).smooth_at
  --   smooth_one_jet_bundle_proj.fst.snd.smooth_at le_top,
  -- simp_rw [prod.mk.eta],
  -- exact this
end

lemma one_jet_snd_eq (p : one_jet (P √ó E) F) :
  one_jet_snd p = (p.1.2, p.2.1, p.2.2 ‚àòL continuous_linear_map.inr ‚Ñù P E) :=
by simp_rw [one_jet_snd]; sorry -- mfderiv_prod_right

variables (P)
/-- The relation `ùì° ^ P` -/
def rel_loc.relativize (R : rel_loc E F) : rel_loc (P √ó E) F :=
one_jet_snd ‚Åª¬π' R
variables {P}

lemma rel_loc.mem_relativize (R : rel_loc E F) (w : one_jet (P √ó E) F) :
 w ‚àà R.relativize P ‚Üî (w.1.2, w.2.1, w.2.2 ‚àòL continuous_linear_map.inr ‚Ñù P E) ‚àà R :=
by simp_rw [rel_loc.relativize, mem_preimage, one_jet_snd_eq]

lemma rel_loc.is_open_relativize (R : rel_loc E F) (h2 : is_open R) :
  is_open (R.relativize P) :=
h2.preimage continuous_one_jet_snd

open_locale pointwise

lemma relativize_slice {œÉ : one_jet (P √ó E) F}
  {p : dual_pair' (P √ó E)}
  (q : dual_pair' E)
  (hpq : p.œÄ.comp (continuous_linear_map.inr ‚Ñù P E) = q.œÄ) :
  (R.relativize P).slice p œÉ =
  œÉ.2.2 (p.v - (0, q.v)) +·µ• R.slice q (one_jet_snd œÉ) :=
begin
  sorry,
  -- have h2pq : ‚àÄ x : E, p.œÄ ((0 : P), x) = q.œÄ x := Œª x, congr_arg (Œª f : E ‚ÜíL[‚Ñù] ‚Ñù, f x) hpq,
  -- ext1 w,
  -- have h1 : (p.update œÉ.2 w).comp (continuous_linear_map.inr ‚Ñù P E) =
  --   q.update (one_jet_snd œÉ).2 (-œÉ.2 (p.v - (0, q.v)) +·µ• w),
  -- { ext1 x,
  --   simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
  --     ‚Üê continuous_linear_map.map_neg, neg_sub],
  --   obtain ‚ü®u, hu, t, rfl‚ü© := q.decomp x,
  --   have hv : (0, q.v) - p.v ‚àà p.œÄ.ker,
  --   { rw [continuous_linear_map.mem_ker, map_sub, p.pairing, h2pq, q.pairing, sub_self] },
  --   have hup : ((0 : P), u) ‚àà p.œÄ.ker := (h2pq u).trans hu,
  --   rw [q.update_apply _ hu, ‚Üê prod.zero_mk_add_zero_mk, map_add, p.update_ker_pi _ _ hup,
  --     ‚Üê prod.smul_zero_mk, map_smul, vadd_eq_add],
  --   nth_rewrite 0 [‚Üê sub_add_cancel (0, q.v) p.v],
  --   rw [map_add, p.update_ker_pi _ _ hv, p.update_v],
  --   refl },
  -- have := preimage_vadd_neg (show F, from œÉ.2 (p.v - (0, q.v)))
  --   (show set F, from (R.slice (one_jet_snd œÉ) q)),
  -- dsimp only at this,
  -- simp_rw [‚Üê this, mem_preimage, mem_slice, mem_relativize],
  -- dsimp only [one_jet_mk_fst, one_jet_mk_snd],
  -- congr'
end

lemma relativize_slice_eq_univ {œÉ : one_jet (P √ó E) F}
  {p : dual_pair' (P √ó E)}
  (hp : p.œÄ.comp (continuous_linear_map.inr ‚Ñù P E) = 0) :
  ((R.relativize P).slice p œÉ).nonempty ‚Üî
  (R.relativize P).slice p œÉ = univ :=
begin
  sorry
  -- have h2p : ‚àÄ x : E, p.œÄ ((0 : P), x) = 0 := Œª x, congr_arg (Œª f : E ‚ÜíL[‚Ñù] ‚Ñù, f x) hp,
  -- have : ‚àÄ y : F, (p.update œÉ.2.2 y).comp (continuous_linear_map.inr ‚Ñù P E) =
  --   œÉ.2.2.comp (continuous_linear_map.inr ‚Ñù P E),
  -- { intro y,
  --   ext1 x,
  --   simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
  --     p.update_ker_pi _ _ (h2p x)] },
  -- simp_rw [set.nonempty, eq_univ_iff_forall, mem_slice, mem_relativize],
  -- dsimp only [one_jet_mk_fst, one_jet_mk_snd],
  -- simp_rw [this, exists_const, forall_const]
end

variables (P)

lemma rel_loc.ample.relativize (hR : R.is_ample) : (R.relativize P).is_ample :=
begin
  intros p œÉ,
  let p2 := p.œÄ.comp (continuous_linear_map.inr ‚Ñù P E),
  rcases eq_or_ne p2 0 with h|h,
  { intros w hw,
    rw [(relativize_slice_eq_univ h).mp ‚ü®w, hw‚ü©, connected_component_in_univ,
      preconnected_space.connected_component_eq_univ, convex_hull_univ] },
  obtain ‚ü®u', hu'‚ü© := continuous_linear_map.exists_ne_zero h,
  let u := (p2 u')‚Åª¬π ‚Ä¢ u',
  let q : dual_pair' E :=
  ‚ü®p2, u, by rw [p2.map_smul, smul_eq_mul, inv_mul_cancel hu']‚ü©,
  rw [relativize_slice q rfl],
  exact (hR q _).vadd
end

variables {P}


/-- Turn a family of sections of `J¬π(E, E')` parametrized by `P` into a section of `J¬π(P √ó E, E')`.
-/
@[simps]
def family_jet_sec.uncurry (S : family_jet_sec E F P) : jet_sec (P √ó E) F :=
{ f := Œª p, S.f p.1 p.2,
  œÜ := Œª p, fderiv ‚Ñù (Œª z : P √ó E, S.f z.1 p.2) p +
    S.œÜ p.1 p.2 ‚àòL fderiv ‚Ñù prod.snd p,
  f_diff := sorry,
  œÜ_diff := begin
    sorry
    -- refine smooth.one_jet_add _ _,
    -- { intro y,
    --   refine smooth_at_id.one_jet_bundle_mk (S.smooth_bs y) _,
    --   have : smooth_at ((IP.prod I).prod (IP.prod I)) I'
    --     (function.uncurry (Œª x z : P √ó E, S.f z.1 x.2)) (y, y),
    --   { exact S.smooth_bs.comp (smooth_snd.fst.prod_mk smooth_fst.snd) (y, y) },
    --   apply cont_mdiff_at.mfderiv'' (Œª x z : P √ó E, S.f z.1 x.2) this le_top },
    -- { refine smooth.one_jet_comp I (Œª p, p.2) S.smooth smooth_snd.one_jet_ext }
  end }

lemma family_jet_sec.uncurry_œÜ' (S : family_jet_sec E F P) (p : P √ó E) :
  (S.uncurry).œÜ p = fderiv ‚Ñù (Œª z, S.f z p.2) p.1 ‚àòL continuous_linear_map.fst ‚Ñù P E +
  S.œÜ p.1 p.2 ‚àòL continuous_linear_map.snd ‚Ñù P E :=
begin
  simp_rw [S.uncurry_œÜ, fderiv_snd],
  congr' 1,
  sorry
  -- convert mfderiv_comp p
  --   ((S.smooth_bs.comp (smooth_id.prod_mk smooth_const)).mdifferentiable p.1)
  --   (smooth_fst.mdifferentiable p),
  -- simp_rw [mfderiv_fst],
end

lemma family_jet_sec.uncurry_mem_relativize (S : family_jet_sec E F P) {s : P}
  {x : E} : ((s, x), S.uncurry (s, x)) ‚àà R.relativize P ‚Üî (x, S s x) ‚àà R :=
begin
  sorry
  -- simp_rw [rel_loc.relativize, mem_preimage, one_jet_sec.coe_apply, map_left],
  -- congr',
  -- ext v,
  -- simp_rw [S.uncurry_œÜ', continuous_linear_map.comp_apply, continuous_linear_map.add_apply,
  --   continuous_linear_map.comp_apply, continuous_linear_map.inr_apply,
  --   continuous_linear_map.coe_fst', continuous_linear_map.coe_snd',
  --   continuous_linear_map.map_zero, zero_add, S.coe_œÜ]
end

lemma is_holonomic_uncurry (S : family_jet_sec E F P) {p : P √ó E} :
  S.uncurry.is_holonomic_at p ‚Üî (S p.1).is_holonomic_at p.2 :=
begin
  sorry
  -- simp_rw [one_jet_sec.is_holonomic_at, one_jet_sec.snd_eq, S.uncurry_œÜ],
  -- rw [show S.uncurry.f = Œª x, S.uncurry.f x, from rfl, funext S.uncurry_bs],
  -- simp_rw [mfderiv_prod_eq_add (S.smooth_bs.mdifferentiable _), mfderiv_snd, add_right_inj],
  -- dsimp only,
  -- rw [mfderiv_comp p S.smooth_coe_bs.mdifferentiable_at smooth_snd.mdifferentiable_at, mfderiv_snd,
  --   (show surjective (continuous_linear_map.snd ‚Ñù P E), from prod.snd_surjective)
  --     .clm_comp_injective.eq_iff],
  -- refl
end

def family_formal_sol.uncurry (S : R.family_formal_sol P) : formal_sol (R.relativize P) :=
begin
  refine ‚ü®S.to_family_jet_sec.uncurry, _‚ü©,
  rintro ‚ü®s, x‚ü©,
  exact S.to_family_jet_sec.uncurry_mem_relativize.mpr (S.is_sol s x)
end

lemma family_formal_sol.uncurry_œÜ' (S : R.family_formal_sol P) (p : P √ó E) :
  S.uncurry.œÜ p = fderiv ‚Ñù (Œª z, S.f z p.2) p.1 ‚àòL continuous_linear_map.fst ‚Ñù P E +
  S.œÜ p.1 p.2 ‚àòL continuous_linear_map.snd ‚Ñù P E :=
S.to_family_jet_sec.uncurry_œÜ' p

def family_jet_sec.curry (S : family_jet_sec (P √ó E) F G) :
  family_jet_sec E F (G √ó P) :=
{ f := Œª p x, (S p.1).f (p.2, x),
  œÜ := Œª p x, (S p.1).œÜ (p.2, x) ‚àòL fderiv ‚Ñù (Œª x, (p.2, x)) x,
  f_diff := sorry,
  œÜ_diff := begin
    sorry
    -- rintro ‚ü®‚ü®t, s‚ü©, x‚ü©,
    -- refine smooth_at_snd.one_jet_mk (S.smooth_bs.comp smooth_prod_assoc _) _,
    -- have h1 : smooth_at ((J.prod IP).prod I) ùìò(‚Ñù, P √ó E ‚ÜíL[‚Ñù] F)
    --   (in_coordinates (IP.prod I) I' (Œª (p : (G √ó P) √ó E), (p.1.2, p.2))
    --     (Œª (p : (G √ó P) √ó E), (S p.1.1).f (p.1.2, p.2))
    --     (Œª (p : (G √ó P) √ó E), ((S p.1.1).œÜ (p.1.2, p.2))) ((t, s), x)) ((t, s), x),
    -- { apply (smooth_at_one_jet.mp $
    --     smooth_at.comp _ (by exact S.smooth (t, (s, x))) (smooth_prod_assoc ((t, s), x))).2.2 },
    -- have h2 : smooth_at ((J.prod IP).prod I) ùìò(‚Ñù, E ‚ÜíL[‚Ñù] P √ó E)
    --   (in_coordinates I (IP.prod I) prod.snd (Œª (p : (G √ó P) √ó E), (p.1.2, p.2))
    --     (Œª (p : (G √ó P) √ó E),
    --       (mfderiv I (IP.prod I) (Œª (x : E), (p.1.2, x)) p.snd)) ((t, s), x)) ((t, s), x),
    -- { apply cont_mdiff_at.mfderiv''' (Œª (p : (G √ó P) √ó E) (x : E), (p.1.2, x)) prod.snd
    --     (smooth_at_fst.fst.snd.prod_mk smooth_at_snd :
    --       smooth_at (((J.prod IP).prod I).prod I) (IP.prod I) _ (((t, s), x), x))
    --     (smooth_at_snd : smooth_at ((J.prod IP).prod I) _ _ _) le_top },
    -- exact h1.clm_comp_in_coordinates (continuous_at_fst.snd.prod continuous_at_snd) h2
  end }

lemma family_jet_sec.curry_bs (S : family_jet_sec (P √ó E) F G) (p : G √ó P)
  (x : E) : (S.curry p).f x = (S p.1).f (p.2, x) :=
rfl

lemma family_jet_sec.curry_œÜ (S : family_jet_sec (P √ó E) F G) (p : G √ó P)
  (x : E) : (S.curry p).œÜ x = (S p.1).œÜ (p.2, x) ‚àòL fderiv ‚Ñù (Œª x, (p.2, x)) x :=
rfl

lemma family_jet_sec.curry_œÜ' (S : family_jet_sec (P √ó E) F G) (p : G √ó P)
  (x : E) : (S.curry p).œÜ x = (S p.1).œÜ (p.2, x) ‚àòL continuous_linear_map.inr ‚Ñù P E :=
begin
  sorry
  -- rw [S.curry_œÜ],
  -- congr' 1,
  -- refine ((mdifferentiable_at_const I IP).mfderiv_prod smooth_id.mdifferentiable_at).trans _,
  -- rw [mfderiv_id, mfderiv_const],
  -- refl,
end

-- lemma formal_sol.eq_iff {F‚ÇÅ F‚ÇÇ : formal_sol R} {x : E} :
--   F‚ÇÅ x = F‚ÇÇ x ‚Üî F‚ÇÅ.f x = F‚ÇÇ.f x ‚àß F‚ÇÅ.œÜ x = by apply F‚ÇÇ.œÜ x :=
-- by { simp_rw [prod.ext_iff, formal_sol.fst_eq, heq_iff_eq, prod.ext_iff, eq_self_iff_true,
--   true_and], refl }

lemma family_jet_sec.is_holonomic_at_curry
  (S : family_jet_sec (P √ó E) F G)
  {t : G} {s : P} {x : E} (hS : (S t).is_holonomic_at (s, x)) :
  (S.curry (t, s)).is_holonomic_at x :=
begin
  sorry
  -- simp_rw [one_jet_sec.is_holonomic_at, (S.curry _).snd_eq, S.curry_œÜ] at hS ‚ä¢,
  -- dsimp only,
  -- rw [show (S.curry (t, s)).f = Œª x, (S.curry (t, s)).f x, from rfl, funext (S.curry_bs _)],
  -- dsimp only,
  -- refine (mfderiv_comp x (S t).smooth_bs.mdifferentiable_at
  --   ((mdifferentiable_at_const I IP).prod_mk smooth_id.mdifferentiable_at)).trans _,
  -- rw [id, hS],
  -- refl,
end

lemma family_jet_sec.curry_mem (S : family_jet_sec (P √ó E) F G)
  {p : G √ó P} {x : E} (hR : ((p.2, x), S p.1 (p.2, x)) ‚àà R.relativize P) :
  (x, S.curry p x) ‚àà R :=
begin
  sorry
  -- simp_rw [rel_loc.relativize, mem_preimage, one_jet_sec.coe_apply,
  --   map_left] at hR ‚ä¢,
  -- convert hR,
  -- ext v,
  -- simp_rw [S.curry_œÜ']
end


def family_formal_sol.curry (S : family_formal_sol G (R.relativize P)) :
  family_formal_sol (G √ó P) R :=
‚ü®S.to_family_jet_sec.curry, Œª p x, S.to_family_jet_sec.curry_mem (S.is_sol _ _)‚ü©

lemma family_formal_sol.curry_œÜ (S : family_formal_sol G (R.relativize P)) (p : G √ó P)
  (x : E) : (S.curry p).œÜ x = (S p.1).œÜ (p.2, x) ‚àòL fderiv ‚Ñù (Œª x, (p.2, x)) x :=
rfl

lemma family_formal_sol.curry_œÜ' (S : family_formal_sol G (R.relativize P)) (p : G √ó P)
  (x : E) : (S.curry p).œÜ x = (S p.1).œÜ (p.2, x) ‚àòL continuous_linear_map.inr ‚Ñù P E :=
S.to_family_jet_sec.curry_œÜ' p x

lemma curry_eq_iff_eq_uncurry {ùìï : family_formal_sol G (R.relativize P)}
  {ùìï‚ÇÄ : R.family_formal_sol P} {t : G} {x : E} {s : P}
  (h : ùìï t (s, x) = ùìï‚ÇÄ.uncurry (s, x)) :
  (ùìï.curry (t, s)) x = ùìï‚ÇÄ s x :=
begin
  sorry,
  -- simp_rw [formal_sol.eq_iff] at h ‚ä¢,
  -- refine ‚ü®h.1, _‚ü©,
  -- simp_rw [ùìï.curry_œÜ', h.2, ùìï‚ÇÄ.uncurry_œÜ'],
  -- ext v,
  -- simp_rw [continuous_linear_map.comp_apply, continuous_linear_map.add_apply,
  --   continuous_linear_map.comp_apply,
  --   continuous_linear_map.inr_apply, continuous_linear_map.coe_fst',
  --   continuous_linear_map.coe_snd', continuous_linear_map.map_zero, zero_add],
  -- refl
end

-- lemma rel_loc.family_formal_sol.parametric_h_principle
--   (R : rel_loc E F) {C : set (P √ó E)}
--   (Œµ : E ‚Üí ‚Ñù) (h : (R.relativize P).satisfies_h_principle C (Œª x, Œµ x.2)) :
--   R.satisfies_h_principle_with IP C Œµ :=
-- begin
--   intros ùìï‚ÇÄ hùìï‚ÇÄ,
--   obtain ‚ü®ùìï, h1ùìï, h2ùìï, h3ùìï, h4ùìï‚ü© := h ùìï‚ÇÄ.uncurry _,
--   swap,
--   { refine hùìï‚ÇÄ.mono (Œª p hp, ùìï‚ÇÄ.to_family_jet_sec.is_holonomic_uncurry.mpr hp) },
--   refine ‚ü®ùìï.curry, _, _, _, _‚ü©,
--   { intros s x, exact curry_eq_iff_eq_uncurry (h1ùìï (s, x)) },
--   { intros s x, exact ùìï.to_family_jet_sec.is_holonomic_at_curry (h2ùìï (s, x)) },
--   { refine h3ùìï.mono _, rintro ‚ü®s, x‚ü© hp t, exact curry_eq_iff_eq_uncurry (hp t) },
--   { intros t s x, exact (h4ùìï t (s, x)) },
-- end



end parameter_space


section parametric_h_principle


variables {E : Type*} [normed_add_comm_group E] [normed_space ‚Ñù E] [finite_dimensional ‚Ñù E]
          {F : Type*} [normed_add_comm_group F] [normed_space ‚Ñù F] [measurable_space F] [borel_space F]
          [finite_dimensional ‚Ñù F]
          {G : Type*} [normed_add_comm_group G] [normed_space ‚Ñù G]
          {P : Type*} [normed_add_comm_group P] [normed_space ‚Ñù P]

variables [finite_dimensional ‚Ñù E] [finite_dimensional ‚Ñù F]

variables {R : rel_loc E F} (h_op: is_open R) (h_ample: R.is_ample) (L : landscape E)
variables {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ)

include h_op h_ample Œµ_pos


lemma rel_loc.family_formal_sol.improve_htpy {ùìï : family_formal_sol P R}
  (C : set P) (hC : is_closed C)
  (h_hol : ‚àÄ·∂† s near C, ‚àÄ x, (ùìï s).is_holonomic_at x) :
  ‚àÉ H : family_formal_sol (‚Ñù √ó P) R,
    (‚àÄ x, H (0, x) = ùìï x)
    -- ‚àß
    -- (‚àÄ·∂† x near L.C, ‚àÄ t, H t x = ùìï x) ‚àß
    -- (‚àÄ x, x ‚àâ L.K‚ÇÅ ‚Üí ‚àÄ t, H t x = ùìï x) ‚àß
    -- (‚àÄ x t, ‚à•(H t).f x - ùìï.f x‚à• ‚â§ Œµ)  ‚àß
    -- (‚àÄ·∂† x near L.K‚ÇÄ, (H 1).is_holonomic_at x)
    :=
begin
  sorry
  -- rcases rel_loc.formal_sol.improve h_op h_ample Œµ_pos h_hol with ‚ü®H, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ, h‚ÇÜ‚ü©,
  -- exact‚ü®{is_sol := h‚ÇÖ, ..H}, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ, h‚ÇÜ‚ü©
end

/- not the full local h-principle sphere eversion,
but just a homotopy of solutions from a homotopy of formal solutions
We don't use the `L.C` in the statement, since we want a set in `‚Ñù`, not in `E`. -/
lemma rel_loc.htpy_formal_sol.exists_sol (ùìï : R.htpy_formal_sol) (C : set ‚Ñù) (hC : is_closed C)
  (h_hol : ‚àÄ·∂† t near C, ‚àÄ x, (ùìï t).is_holonomic_at x) :
  ‚àÉ f : ‚Ñù ‚Üí E ‚Üí F,
    (ùíû ‚àû $ uncurry f) ‚àß
    (‚àÄ·∂† t near C, ‚àÄ x, f t x = ùìï.f t x) ‚àß
    (‚àÄ x, x ‚àâ L.K‚ÇÅ ‚Üí ‚àÄ t, f t x = ùìï.f t x) ‚àß
    (‚àÄ·∂† x near L.K‚ÇÄ, ‚àÄ t, ‚à•f t x - ùìï.f t x‚à• ‚â§ Œµ) ‚àß
    (‚àÄ·∂† x near L.K‚ÇÄ, ‚àÄ t, (x, f t x, D (f t) x) ‚àà R) :=
begin
  let := ùìï.uncurry,
  have := family_formal_sol.uncurry ùìï,
  sorry
end

end parametric_h_principle
