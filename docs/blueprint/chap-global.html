<!DOCTYPE html>
<html lang="en">
<head>
<script>
  MathJax = { 
    tex: {
		    inlineMath: [['$','$'], ['\\(','\\)']]
	} }
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
<meta name="generator" content="plasTeX" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Global theory of open and ample relations</title>
<link rel="prev" href="chap-local.html" title="Local theory of convex integration" />
<link rel="up" href="index.html" title="The sphere eversion project" />
<link rel="stylesheet" href="styles/theme-blue.css" />
<link rel="stylesheet" href="styles/amsthm.css" />
<link rel="stylesheet" href="styles/showmore.css" />
<link rel="stylesheet" href="styles/stylecours.css" />
</head>

<body>
<header>
<svg  id="toc-toggle" class="icon icon-list-numbered "><use xlink:href="symbol-defs.svg#icon-list-numbered"></use></svg>
<h1 id="doc_title"><a href="index.html">The sphere eversion project</a></h1>
</header>

<div class="wrapper">
<nav class="toc">
<ul class="sub-toc-0">
<li class="">
  <a href="sect0001.html"><span class="toc_ref"></span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="chap-loops.html"><span class="toc_ref">1</span> <span class="toc_entry">Loops</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-loops.html#sec:loops_introduction"><span class="toc_ref">1.1</span> <span class="toc_entry">Introduction</span></a>
 </li>
<li class="">
  <a href="chap-loops.html#sec:preliminaries"><span class="toc_ref">1.2</span> <span class="toc_entry">Preliminaries</span></a>
 </li>
<li class="">
  <a href="chap-loops.html#a0000000011"><span class="toc_ref">1.3</span> <span class="toc_entry">Constructing loops</span></a>
 </li>

  </ul>
 </li>
<li class="">
  <a href="chap-local.html"><span class="toc_ref">2</span> <span class="toc_entry">Local theory of convex integration</span></a>
  <span class="expand-toc">▶</span>
  <ul class="sub-toc-1">
     <li class="">
  <a href="chap-local.html#sec:convex_integration_intro"><span class="toc_ref">2.1</span> <span class="toc_entry">Key construction</span></a>
 </li>
<li class="">
  <a href="chap-local.html#sec:inductive_step"><span class="toc_ref">2.2</span> <span class="toc_entry">The main inductive step</span></a>
 </li>
<li class="">
  <a href="chap-local.html#sec:ample_differential_relations"><span class="toc_ref">2.3</span> <span class="toc_entry">Ample differential relations</span></a>
 </li>

  </ul>
 </li>
<li class=" active current">
  <a href="chap-global.html"><span class="toc_ref">3</span> <span class="toc_entry">Global theory of open and ample relations</span></a>
  <span class="expand-toc">▼</span>
  <ul class="sub-toc-1 active">
     <li class="">
  <a href="chap-global.html#a0000000012"><span class="toc_ref">3.1</span> <span class="toc_entry">Preliminaries</span></a>
 </li>
<li class="">
  <a href="chap-global.html#a0000000013"><span class="toc_ref">3.2</span> <span class="toc_entry">First order differential relations</span></a>
 </li>
<li class="">
  <a href="chap-global.html#sec:general_theory"><span class="toc_ref">3.3</span> <span class="toc_entry">The \(h\)-principle for open and ample differential relations</span></a>
 </li>

  </ul>
 </li>
<li ><a href="dep_graph_document.html">Dependency graph</a></li>
</ul>
</nav>

<div class="content">
<div class="content-wrapper">


<div class="main-text">
<h1 id="chap:global">3 Global theory of open and ample relations</h1>

<h1 id="a0000000012">3.1 Preliminaries</h1>
<h2 id="sub:localisation_data">3.1.1 Localisation data</h2>

<p>In order to conveniently globalize the theory of the previous chapter, we’ll need a number of constructions and lemmas. By definition, manifolds are covered by open sets that are diffeomorphic to open sets of vector spaces. But for us it is slightly more convenient to work with smooth open embeddings of whole vector spaces. Here a smooth open embedding from a manifold \(X\) to a manifold \(Y\) is a smooth map \(φ : X → Y\) which is open and for which there is some smooth \(ψ : φ(X) → X\) such that \(ψ ∘ φ = \operatorname{Id}\) and \(φ ∘ ψ = \operatorname{Id}\). Remember that a family of sets \(V_i\) in a topological space \(X\) is locally finite if every point of \(X\) has a neighborhood that intersects only finitely many \(V_i\). Note that in this whole text, every manifold is paracompact by definition. In particular their topology are metrizable and we will arbitrarily fix a compatible distance function on every manifold. </p>
<p><div class="definition_thmwrapper" id="def:update">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.1</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:update">#</a>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p> Given smooth open embeddings \(φ : X → M\) and \(ψ : Y → N\), for any map \(f : M → N\) such that \(f(φ(X)) ⊂ ψ(Y)\), and every map \(g : X → Y\), the update of \(f\) using \(g\) is the map from \(M\) to \(N\) sending \(m\) to \(ψ ∘ g ∘ φ⁻¹(m)\) if \(m ∈ φ(E)\) and \(f(m)\) otherwise. </p>

  </div>
</div> </p>
<p><div class="lemma_thmwrapper" id="lem:updating">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.2</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:updating">#</a>
    <a class="icon proof" href="chap-global.html#a0000000068"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:update">Definition 3.1</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  Let \(φ : X → M\) and \(ψ : Y → N\) be smooth open embeddings. Let \(K\) and \(L\) be compact sets in \(E\) and \(F\) respectively. Let \(f : M → N\) be a smooth map such that \(f(φ(X)) ⊂ ψ(L)\). Let \(g : X → Y\) be a smooth map which agrees with \(ψ⁻¹∘f∘φ\) outside of \(K\). Denote by \(f'\) the update of \(f\) using \(g\). </p>
<ul class="itemize">
  <li><p>\(f'\) is a smooth map from \(M\) to \(N\). </p>
</li>
  <li><p>For every continuous function \(ε : M → ℝ_{{\gt} 0}\), there is some positive number \(η\) such that, if \(∀ e, ‖g(e) - ψ⁻¹∘f∘φ(e)‖ {\lt} η\) then \(∀ m ∈ M, d(f(m), f'(m)) {\lt} ε(m)\). </p>
</li>
</ul>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000068">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>In order to prove smoothness of \(f'\), note that \(M = φ(E) ∪ φ(L)^c\). Both those sets are open and \(f'\) coincide with \(ψ ∘ g ∘ φ⁻¹\) on the first one and \(f\) on the second one. </p>
<p>Let \(ε\) be a positive continuous function on \(M\). Since \(K\) is compact, we get a positive number \(ε₀\) such that \(ε(m) ≥ ε₀\) for each \(m\) in \(K\). We denote by \(L₁\) the closed \(1\)-thickening of \(ψ⁻¹∘f∘φ(K)\) in \(F\). This is a compact set so \(ψ\) is uniformly continuous on \(L₁\) and we get a positive \(τ\) such that for all \(x\) and \(y\) in \(L₁\), \(‖x - y‖ {\lt} τ ⇒ d(ψ(x), ψ(y)) {\lt} ε₀\). </p>
<p>We now prove that \(η = \min (τ, 1)\) is suitable. Assume that \(∀ e, ‖g(e) - ψ⁻¹∘f∘φ(e)‖ {\lt} η\). Let \(m\) be a point in \(M\). If \(m\) isn’t in \(φ(K)\) then \(f'(m) = f(m)\) and in particular \(d(f(m), f'(m)) {\lt} ε(m)\). Now assume that \(m = φ(e)\) for some \(e\) in \(K\). By assumption \(‖g(e) - ψ⁻¹∘f∘φ(e)‖ {\lt} η\). In particular \(‖g(e) - ψ⁻¹∘f∘φ(e)‖ {\lt} 1\) hence \(g(e)\) is in \(L₁\). Since \(ψ⁻¹∘f∘φ(e)\) is also in \(L₁\) and \(‖g(e) - ψ⁻¹∘f∘φ(e)‖ {\lt} τ\), we get \(d(ψ∘ g(e), ψ ∘ ψ⁻¹∘f∘φ(e)) {\lt} ε₀\). This precisely means that \(d(f'(m), f(m)) {\lt} ε₀\). Since \(m\) is in \(K\), this is less than \(ε(m)\). </p>

  </div>
</div>
<p><div class="lemma_thmwrapper" id="lem:nice_atlas">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.3</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:nice_atlas">#</a>
    <a class="icon proof" href="chap-global.html#a0000000069"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p> Let \(M\) be a manifold modelled on the normed space \(E\) and \((V_j)_{j ∈ J}\) a cover of \(M\) by open sets. There exists a countable set \(ι\) and a family of smooth open embeddings \(φ : ι × E → M\) such that </p>
<ul class="itemize">
  <li><p>for each \(i\) there is some \(j\) such that \(φ_i(E) \subseteq V_j\), </p>
</li>
  <li><p>\(i ↦ φ_i(E)\) is a locally-finite collection of sets in \(M\), </p>
</li>
  <li><p>\(⋃_i φ_i(B_E(0, 1)) = M\) where \(B_E(0, 1)\) is the open unit ball in \(E\). </p>
</li>
</ul>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000069">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>The proof is a standard compact-exhaustion argument. Let \(K_0, K_1, K_2, \ldots \) be a compact exhaustion of \(M\) and define: </p>
<div class="displaymath" id="a0000000070">
  \begin{align*}  C_n & = K_{n+2} \smallsetminus K_{n+1}^o,\\ U_n & = K_{n+3}^o \smallsetminus K_n. \end{align*}
</div>
<p> Thus: </p>
<ul class="itemize">
  <li><p>\(C_n\) is compact, </p>
</li>
  <li><p>\(U_n\) is open, </p>
</li>
  <li><p>\(C_n \subseteq U_n\), </p>
</li>
  <li><p>\(\bigcup _n C_n = M\), </p>
</li>
  <li><p>\(U_n \cap U_m = \emptyset \) if \(|n - m| {\gt} 2\). </p>
</li>
</ul>
<p> For any \(y \in E\) and \(r {\gt} 0\), fix a smooth diffeomorphism \(f_{y,r} : E \simeq B_E(y, r)\) such that \(f_{y,r}(0) = y\). For each \(n\) and \(x \in C_n\), let \(\psi _x\) be a smooth chart mapping an open neighbourhood of \(x\) to an open set of the model space \(E\). Writing \(y = \psi _x (x) \in E\), let: </p>
<div class="displaymath" id="a0000000071">
  \begin{align*}  B_{n, x} & = \psi _x^{-1} (B_E(y, r)),\\ W_{n, x} & = \psi _x^{-1} (f_{y,r} (B_E (0, 1))),\\ \end{align*}
</div>
<p> for some \(r {\gt} 0\) (which may depend on \(n\), \(x\)) sufficiently small that: </p>
<ul class="itemize">
  <li><p>\(B_E(y, r)\) lies in the target of the chart \(\psi _x\), </p>
</li>
  <li><p>\(B_{n,x}\) is contained in \(U_n\), </p>
</li>
  <li><p>\(B_{n,x}\) is contained in \(V_j\) for some \(j\). </p>
</li>
</ul>
<p> Note that \(x \in W_{n,x}\). For each \(n\), choose a finite subcovering of \(C_n\) by \(W_{n, x_1}, \ldots , W_{n, x_{l_n}}\) and define \(\iota \subseteq ℕ \times M\) by: </p>
<div class="displaymath" id="a0000000072">
  \begin{align*}  \iota = \bigcup _n \{  (n, x_1), \ldots , (n, x_{l_n}) \}  . \end{align*}
</div>
<p> Note that \(\iota \) is countable and furthermore: </p>
<ul class="itemize">
  <li><p>for each \(i \in \iota \), there is some \(j\) such that \(B_i \subseteq V_j\), </p>
</li>
  <li><p>\((B_i)_{i \in \iota }\) is locally-finite (indeed more is true: \(B_i\) meets only finitely-many \(B_{i'}\) for \(i, i' \in \iota \) since \(B_{m, x} \cap B_{n, x'} = \emptyset \) if \(|n - m| {\gt} 2\)), </p>
</li>
  <li><p>\((W_i)_{i \in \iota }\) covers \(M\). </p>
</li>
</ul>
<p> Given \(i = (n, x_j) \in \iota \), the required map \(\phi _i : E \to M\) is just: </p>
<div class="displaymath" id="a0000000073">
  \begin{align*}  E \simeq B_E(y_j, r) \simeq B_{n,j} \subseteq M. \end{align*}
</div>

  </div>
</div>
<p><div class="definition_thmwrapper" id="def:localisation_data">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.4</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:localisation_data">#</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/localisation_data.lean#L23">localisation_data</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Let \(f : M → N\) be a continuous map between manifolds. A localisation data for \(f\) is a tuple \((E, F, ι, ι', φ, ψ, j)\) where \(E\) and \(F\) are normed vector spaces, \(ι\) is a finite or countable set, \(ι'\) is a set (that is morally also finite or countable but that will play no role), \(φ : ι × E → M\) and \(ψ : ι' × F → N\) are families of smooth open embeddings, and \(j : ι → ι'\) such that: </p>
<ul class="itemize">
  <li><p>\(⋃_i φ_i(B_E) = M\)where \(B_E\) is the open unit ball in \(E\). </p>
</li>
  <li><p>\(∀ i, f(φ_i(E)) ⊂ ψ_{j(i)}(B_F)\) where \(B_F\) is the open unit ball in \(F\) </p>
</li>
  <li><p>\(⋃_i ψ_i(B_F) = M\) where \(B_F\) is the open unit ball in \(F\). </p>
</li>
</ul>
<p> Such a tuple will be denoted by \((φ, ψ, j)\) for brevity. </p>

  </div>
</div> </p>
<p><div class="lemma_thmwrapper" id="lem:ex_localisation">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.5</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:ex_localisation">#</a>
    <a class="icon proof" href="chap-global.html#a0000000074"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:localisation_data">Definition 3.4</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/localisation_data.lean#L76">std_localisation_data</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>   Any continuous map between manifolds has some localisation data. </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000074">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p> The preceding lemma (applied to the trivial cover of \(N\) by itself) gives a family of \(ψ : ι' × F → N\) of open smooth embeddings that the images of \(B_F\) cover \(N\). We then apply this lemma again to the cover of \(M\) given by all \(f⁻¹(ψ_j(B_F))\). </p>

  </div>
</div>
<p>The general idea will be to apply the results of the previous chapters to all the \(ψ_{j(i)}⁻¹ ∘ f ∘ φ_i : E → F\) for some maps \(f\). However we must be careful that doing this for some \(i\) does not ruin the setup for the next \(i\). This is easier to control using a distance function on the target manifold as in <a href="chap-global.html#lem:localisation_stability">Lemma 3.7</a> below. First we need a general lemma about a single metric space (actually the formalized statement is stronger, it assumes only closed sets instead of compact ones, but here we explain the easier proof which is sufficient for our purposes). </p>
<p><div class="lemma_thmwrapper" id="lem:stability_cover">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.6</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:stability_cover">#</a>
    <a class="icon proof" href="chap-global.html#a0000000075"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/mathlib/blob/cad35c7967a398ed8e6fcc378aac2a9324cc3304/src/topology/metric_space/partition_of_unity.lean#L139">metric.exists_continuous_real_forall_closed_ball_subset</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  In a metric space \(X\), let \(V : ι → \operatorname{\mathcal{P}}{X}\) be a locally finite collection of open subsets of \(X\) and let \(K : ι → \operatorname{\mathcal{P}}{X}\) be a family of compact subsets such that \(K_i ⊂ V_i\) for all \(i\). There existe a continuous function \(δ : X → ℝ_{{\gt} 0}\) such that: </p>
<div class="displaymath" id="a0000000076">
  \[  ∀ x\,  x',\;  ∀ i, \left[x ∈ K_i \text{ and } d(x, x') {\lt} δ(x)\right] ⇒ x' ∈ V_i.  \]
</div>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000075">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>We first note that, for any given \(i\), compactness of \(K\) and openness of \(V_i\) give a positive number \(δ_i\) such that the \(δ_i\)-neighborhood of \(K_i\) is contained in \(V_i\). We now prove that solutions exist locally. Let \(x\) be any point in \(X\). From the local finiteness assumption, we get a neighborhood \(U\) of \(x\) such that \(\{ i | U ∩ V_i ≠ ∅\} \) is finite. The constant function with value the minimum of the corresponding \(δ_i\) is a solution on \(U\). Since the condition we put on \(δ\) is convex, we can glue those local solutions using a partition of unity. </p>

  </div>
</div>
<p><div class="lemma_thmwrapper" id="lem:localisation_stability">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.7</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:localisation_stability">#</a>
    <a class="icon proof" href="chap-global.html#a0000000077"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:localisation_data">Definition 3.4</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  Let \(f : M → N\) be a continuous map between manifolds, and let \((φ, ψ, i)\) be some localisation data for \(f\). There exists some continuous positive function \(ε : M → ℝ_{{\gt}0}\) such that: </p>
<div class="displaymath" id="a0000000078">
  \[  ∀ g : M → N, \big [∀ m,\;  d(f(m), g(m)) {\lt} ε(m)\big ] ⇒ ∀ i,\;  g(φ_i(E)) ⊂ ψ_{j(i)}(F).  \]
</div>

  </div>
</div> Note that, in the preceding lemma, the conclusion \(g(φ_i(E)) ⊂ ψ_{j(i)}(F)\) is weaker than the condition \(f(φ_i(E)) ⊂ ψ_{j(i)}(B_F)\) that appears in the definition of localisation data. </p>
<p>The condition \(∀ m,\;  d(f(m), g(m)) {\lt} ε(m)\) will be abbreviated \(d(f, g) {\lt} ε\). </p>
<div class="proof_wrapper" id="a0000000077">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p> The preceding lemma applied to the family of open sets \(ψ_j(F)\) and the family of compact sets \(ψ_j(\overline{B_F})\) give a positive continuous function \(δ : N → ℝ\) such that \(ε = δ ∘ f\) is suitable. Indeed, assume \(g : M → N\) satisfies \(d(f, g) {\lt} ε\) and fix some \(i\) and some \(m ∈ φ_i(E)\). We know \(f(m) ∈ ψ_{j(i)}(\overline{B_F})\) and our assumption on \(g\) gives \(d(f(m), g(m)) {\lt} δ(f(m))\). So the property of \(δ\) ensures \(g(m) ∈ ψ_{j(i)}(F)\). </p>

  </div>
</div>
<p>We now introduce a seemingly abstract definition, but its only goal is to treat uniformly the case of \(ℕ\) and finite sets \(\{ 0, \dots , n\} \). </p>
<p><div class="definition_thmwrapper" id="def:convenient_indexing">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.8</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:convenient_indexing">#</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/indexing.lean#L19">indexing</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>  A convenient indexing set is a totally ordered set \(ι\) equipped with maps \(π : ℕ → ι\) and \(σ : ι → ℕ\) such that \(π\) is order preserving and \(π ∘ σ = \operatorname{Id}\) (in particular \(π\) is surjective). </p>

  </div>
</div> </p>
<p>In the case \(ι = ℕ\) we will use \(π = σ = \operatorname{Id}\) while in the case \(ι = \{ 0, \dots , n-1\} \) we use the unique order-preserving retraction as \(π\) and the inclusion as \(σ\). </p>
<p><div class="lemma_thmwrapper" id="lem:loc_ultim_const">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.9</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:loc_ultim_const">#</a>
    <a class="icon proof" href="chap-global.html#a0000000079"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/mathlib/blob/cad35c7967a398ed8e6fcc378aac2a9324cc3304/src/topology/locally_finite.lean#L154">locally_finite.exists_forall_eventually_at_top_eventually_eq</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  Let \(M\) a topological space and \(Z\) a set. Let \(f : ℕ × M → Z\) be a sequence of functions. If the family of sets \(n ↦ \{ x \; \| \;  f_{n+1}(x) = f_n(x)\} \) is locally finite then there exists \(U : M → \operatorname{\mathcal{P}}{M}\) and \(n₀ : M → ℕ\) such that: </p>
<div class="displaymath" id="a0000000080">
  \[  ∀ x,\;  U_x ∈ 𝓝_x \text{ and } ∀ n ≥ n₀(x),\;  f_n|_{U_x} = f_{n₀(x)}|_{U_x}.  \]
</div>

  </div>
</div> </p>
<p>Note that the conclusion of above lemma ensures that the sequence \(f_n\) converges pointwise and the limit inherits all local properties of the \(f_n\) (such as continuity or differentiability when applicable). </p>
<div class="proof_wrapper" id="a0000000079">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>The local finiteness assumption provides a function \(U : M → \operatorname{\mathcal{P}}{M}\) such that </p>
<div class="displaymath" id="a0000000081">
  \[  ∀ x,\;  U_x ∈ 𝓝_x \text{ and } \{ n \; |\;  \{ y \; |\; f_n(y) ≠ f_{n+1}(y)\}  ∩ U_x ≠ ∅\}  \text{ is finite}.  \]
</div>
<p> For any \(x\), we denote by \(N_x\) the largest \(n\) of the finite set mentioned above. By construction, \(n₀ \! :x ↦ N_x + 1\) is suitable. </p>

  </div>
</div>
<h2 id="sec:vector_bundles_operations">3.1.2 Vector bundles operations</h2>

<p><div class="definition_thmwrapper" id="def:pull_back_bundle">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.10</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:pull_back_bundle">#</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/to_mathlib/geometry/manifold/vector_bundle/basic_core_constructions.lean#L58">basic_smooth_vector_bundle_core.pullback</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>  For every bundle \(p : E → B\) and every map \(f \! :B' → B\), the pull-back bundle \(f^*E → B'\) is defined by \(f^*E = \{ (b', e) ∈ B' × E \; |\;  p(e) = f(b')\} \) with the obvious projection to \(B'\). </p>

  </div>
</div> </p>
<p>The case of vector bundles. </p>
<p><div class="definition_thmwrapper" id="def:hom_bundle">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.11</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:hom_bundle">#</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/to_mathlib/geometry/manifold/vector_bundle/basic_core_constructions.lean#L268">basic_smooth_vector_bundle_core.hom</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>  Let \(E → B\) and \(F → B\) be two vector bundles over some smooth manifold \(B\). The bundle \(\operatorname{Hom}(E, F) → B\) is the set of linear maps from \(E_b\) to \(F_b\) for some \(b\) in \(B\), with the obvious projection map. </p>

  </div>
</div> </p>
<p>Set-theoretically, one can define \(\operatorname{Hom}(E, F)\) as the set of subsets \(S\) of \(E × F\) such that there exists \(b\) such that \(S ⊂ E_b × F_b\) and \(S\) is the graph of a linear map. But the type theory formalization will use other tricks here. The facts that really matter are listed in <a href="chap-global.html#lem:one_jet_extension_prop">lemma 3.14</a>. </p>
<h2 id="a0000000082">3.1.3 Jets spaces</h2>
<p><div class="definition_thmwrapper" id="def:one_jet_space">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.12</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:one_jet_space">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:pull_back_bundle">Definition 3.10</a></li>
          <li><a href="chap-global.html#def:hom_bundle">Definition 3.11</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_bundle.lean#L30">one_jet_bundle_core</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   Let \(M\) and \(N\) be smooth manifolds. Denote by \(p_1\) and \(p_2\) the projections of \(M × N\) to \(M\) and \(N\) respectively. </p>
<p>The space \(J^1(M, N)\) of \(1\)-jets of maps from \(M\) to \(N\) is \(Hom(p_1^*TM, p_2^*TN)\) </p>

  </div>
</div> </p>
<p>We will use notations like \((m, n, φ)\) to denote an element of \(J^1(M, N)\), but one should keep in mind that \(J^1(M, N)\) is not a product, since \(φ\) lives in \(\operatorname{Hom}(T_mM, T_nN)\) which depends on \(m\) and \(n\). </p>
<p><div class="definition_thmwrapper" id="def:one_jet_extension">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.13</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:one_jet_extension">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_space">Definition 3.12</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_bundle.lean#L145">one_jet_ext</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   The \(1\)-jet of a smooth map \(f \! :M → N\) is the map from \(m\) to \(J^1(M, N)\) defined by \(j^1f(m) = (m, f(m), T_mf)\). </p>

  </div>
</div> </p>
<p>The composition of a section \(\mathcal{F}\! :M → J^1(M, N)\) with the projection onto \(N\) will sometimes be denoted by \(\operatorname{bs}\mathcal{F}\! :M → N\) and called the base map of \(\mathcal{F}\). For any \(m\), \(\mathcal{F}(m)_φ\) will denote the component of \(\mathcal{F}(m)\) living in \(\operatorname{Hom}(T_mM, T_{\operatorname{bs}\mathcal{F}(m)}N)\). </p>
<p><div class="lemma_thmwrapper" id="lem:one_jet_extension_prop">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.14</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:one_jet_extension_prop">#</a>
    <a class="icon proof" href="chap-global.html#a0000000083"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_extension">Definition 3.13</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_bundle.lean#L178">smooth.one_jet_ext</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_bundle.lean#L164">one_jet_ext_proj</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>   For every smooth map \(f \! :M → N\), </p>
<ol class="enumerate">
  <li><p> \(j^1f\) is smooth </p>
</li>
  <li><p> \(j^1f\) is a section of \(J^1(M, N) → M\) </p>
</li>
  <li><p> \(j^1f\) composed with \(J^1(M, N) → N\) is \(f\). </p>
</li>
</ol>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000083">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>This is obvious by construction. </p>

  </div>
</div>
<p><div class="definition_thmwrapper" id="def:holonomic_section">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.15</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:holonomic_section">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_space">Definition 3.12</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_sec.lean#L77">one_jet_sec.is_holonomic_at</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/one_jet_sec.lean#L82">one_jet_sec.is_holonomic_at_iff</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A section \(\mathcal{F}\) of \(J^1(M, N) → M\) is called holonomic if it is the \(1\)–jet of its base map. Equivalently, \(\mathcal{F}\) is holonomic if there exists \(f \! :M → N\) such that \(\mathcal{F}= j^1f\), since such a map is necessarily \(\operatorname{bs}\mathcal{F}\). </p>

  </div>
</div> </p>
<h1 id="a0000000013">3.2 First order differential relations</h1>
<p><div class="definition_thmwrapper" id="def:rel">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.16</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:rel">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_space">Definition 3.12</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L49">rel_mfld</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A first order differential relation for maps from \(M\) to \(N\) is a subset \(\mathcal{R}\) of \(J^1(M, N)\). </p>

  </div>
</div> </p>
<p><div class="definition_thmwrapper" id="def:formal_sol">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.17</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:formal_sol">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:rel">Definition 3.16</a></li>
          <li><a href="chap-global.html#def:one_jet_extension">Definition 3.13</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L62">formal_sol</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L56">sol</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A formal solution of a differential relation \(\mathcal{R}⊂ J^1(M, N)\) is a section of \(J^1(M, N) → M\) taking values in \(\mathcal{R}\). A solution of \(\mathcal{R}\) is a map from \(M\) to \(N\) whose \(1\)–jet extension is a formal solution. </p>

  </div>
</div> </p>
<p><div class="definition_thmwrapper" id="def:htpy_formal_sol">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.18</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:htpy_formal_sol">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:formal_sol">Definition 3.17</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L99">htpy_formal_sol</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A homotopy of formal solutions of \(\mathcal{R}\) is a family of sections \(\mathcal{F}: ℝ × M → J^1(M, N)\) which is smooth over \([0, 1] × M\) and such that each \(m ↦ \mathcal{F}(t, m)\) is a formal solution when \(t\) is in \([0, 1]\). </p>

  </div>
</div> </p>
<p>The next definition will be used in cases where \(X\) and \(Y\) are vector spaces, in order to relate the global theory to the local one. </p>
<p><div class="definition_thmwrapper" id="def:transfer_map">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.19</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:transfer_map">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_space">Definition 3.12</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L164">one_jet_bundle.transfer</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L184">one_jet_sec.localize_fun</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L178">rel_mfld.localize</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   Given manifolds \(M\), \(X\), \(N\) and \(Y\) and smooth open embeddings \(g : Y → N\) and \(h : X → M\) we get a transfer map \(ψ_{g, h} : J^1(X, Y) → J^1(M, N)\) defined by </p>
<div class="displaymath" id="a0000000084">
  \[  ψ_{g, h}(x, y, φ) = (h(x), g(y), T_yg ∘ φ ∘ (T_xh)⁻¹)  \]
</div>
<p> and an operator on sections which sends \(\mathcal{F}: M → J^1(M, N)\) to \(Ψ_{g, h}\mathcal{F}: X → J^1(X, Y)\) defined when \(\operatorname{bs}\mathcal{F}(h(X)) ⊂ g(Y)\) by </p>
<div class="displaymath" id="a0000000085">
  \[  Ψ_{g, h}\mathcal{F}(x) = (x, g⁻¹ ∘ \operatorname{bs}\mathcal{F}∘ h(x), (T_{g⁻¹ ∘ \operatorname{bs}\mathcal{F}∘ h(x)}g)⁻¹ ∘ \mathcal{F}(h(x))_φ ∘ T_xh).  \]
</div>
<p> Given a relation \(\mathcal{R}⊂ J^1(M, N)\), the induced relation in \(J^1(X, Y)\) is \(ψ_{g, h}⁻¹\mathcal{R}\). </p>

  </div>
</div> </p>
<p>The following is a localization lemma needed to take advantage of all the work from the previous chapter. </p>
<p><div class="lemma_thmwrapper" id="lem:transfer">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.20</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:transfer">#</a>
    <a class="icon proof" href="chap-global.html#a0000000086"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:transfer_map">Definition 3.19</a></li>
          <li><a href="chap-global.html#def:holonomic_section">Definition 3.15</a></li>
          <li><a href="chap-global.html#def:formal_sol">Definition 3.17</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L191">one_jet_sec.localize</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L227">is_holonomic_at_localize_iff</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L220">one_jet_sec.localize_mem_iff</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>   In the situation of the previous definition, given a section \(\mathcal{F}: M → J^1(M, N)\): </p>
<ul class="itemize">
  <li><p>\(Ψ_{g, h}(\mathcal{F})\) is a smooth section of \(J^1(X, Y)\). </p>
</li>
  <li><p>\(\mathcal{F}\) is holonomic on \(s ⊂ h(X) ∩ \operatorname{bs}\mathcal{F}⁻¹(g(Y))\) if and only if \(Ψ_{g, h}(\mathcal{F})\) is holonomic on \(h⁻¹(s)\). </p>
</li>
  <li><p>\(\mathcal{F}\) is a formal solution of \(\mathcal{R}\) on \(h(X) ∩ \operatorname{bs}\mathcal{F}⁻¹(g(Y)\) if and only if \(Ψ_{g, h}(\mathcal{F})\) is a formal solution of the induced relation \(Ψ_{g, h}⁻¹\mathcal{R}\). </p>
</li>
</ul>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000086">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p> The first point is clear by composition. In order to prove the second point while keeping notations under control, we set \(f(x) = g⁻¹ ∘ \operatorname{bs}\mathcal{F}∘ h\). Using this notation \(Ψ_{g, h}\mathcal{F}(x) = (x, f(x), (T_{f(x)}g)⁻¹ ∘ \mathcal{F}(h(x))_φ ∘ T_xh)\). We have </p>
<div class="displaymath" id="a0000000087">
  \begin{align*}  T_x f & = T_{\operatorname{bs}\mathcal{F}∘ h(x)}(g⁻¹) ∘ T_{h(x)}\operatorname{bs}\mathcal{F}∘ T_x h\\ & = \left(T_{f(x)}g\right)⁻¹ ∘ T_{h(x)}\operatorname{bs}\mathcal{F}∘ T_x h \end{align*}
</div>
<p> hence \(Ψ_{g, h}\mathcal{F}\) is holonomic at \(x\) if and only if \(\left(T_{f(x)}g\right)⁻¹ ∘ \mathcal{F}(h(x))_φ ∘ T_xh = \left(T_{f(x)}g\right)⁻¹ ∘ T_{h(x)}\operatorname{bs}\mathcal{F}∘ T_x h\) and this is equivalent to \(\mathcal{F}(h(x))_φ = T_{h(x)}\operatorname{bs}\mathcal{F}\) which is the holonomy condition for \(\mathcal{F}\) at \(h(x)\). </p>
<p>The third point is a direct consequence of the easy formula \(ψ_{g, h} ∘ Ψ_{g, h}(\mathcal{F}) = F ∘ h\). </p>

  </div>
</div>
<p><div class="definition_thmwrapper" id="def:h-princ">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.21</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:h-princ">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:formal_sol">Definition 3.17</a></li>
          <li><a href="chap-global.html#def:htpy_formal_sol">Definition 3.18</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L103">rel_mfld.satisfies_h_principle</a></li>
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L110">rel_mfld.satisfies_h_principle_with</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A first order differential relation \(\mathcal{R}⊂ J^1(M, N)\) satisfies the \(h\)-principle if every formal solution of \(\mathcal{R}\) is homotopic to a holonomic one. It satisfies the parametric \(h\)-principle if, for every manifold with boundary \(P\), every family \(\mathcal{F}: P × M → J^1(M, N)\) of formal solutions which are holonomic for \(p\) in \(𝓝(∂P)\) is homotopic to a family of holonomic ones relative to \(𝓝(∂P)\). </p>

  </div>
</div> </p>
<h2 id="a0000000088">Parametricity for free</h2>
<p>In many cases, relative parametric \(h\)-principles can be deduced from relative non-parametric ones with a larger source manifold. Let \(X\), \(P\) and \(Y\) be manifolds, with \(P\) seen a parameter space. Denote by \(Ψ\) the map from \(J^1(X × P, Y)\) to \(J^1(X, Y)\) sending \((x, p, y, ψ)\) to \((x, y, ψ ∘ ι_{x, p})\) where \(ι_{x, p} : T_xX → T_xX × T_pP\) sends \(v\) to \((v, 0)\). </p>
<p>To any family of sections \(F_p : x ↦ (f_p(x), φ_{p, x})\) of \(J^1(X, Y)\), we associate the section \(\bar F\) of \(J^1(X × P, Y)\) sending \((x, p)\) to \(\bar F(x, p) := (f_p(x), φ_{p, x} ⊕ ∂f/∂p(x, p))\). </p>
<p><div class="lemma_thmwrapper" id="lem:param_trick">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.22</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:param_trick">#</a>
    <a class="icon proof" href="chap-global.html#a0000000089"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:holonomic_section">Definition 3.15</a></li>
          <li><a href="chap-global.html#def:formal_sol">Definition 3.17</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  In the above setup, we have: </p>
<ul class="itemize">
  <li><p>\(\bar F\) is holonomic at \((x, p)\) if and only if \(F_p\) is holonomic at \(x\). </p>
</li>
  <li><p>\(F\) is a family of formal solutions of some \(\mathcal{R}⊂ J^1(X, Y)\) if and only if \(\bar F\) is a formal solution of \(\mathcal{R}^P := Ψ^{-1}(\mathcal{R})\). </p>
</li>
</ul>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000089">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>TODO…</p>

  </div>
</div>
<p><div class="lemma_thmwrapper" id="lem:param_for_free">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.23</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:param_for_free">#</a>
    <a class="icon proof" href="chap-global.html#a0000000090"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:h-princ">Definition 3.21</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  Let \(\mathcal{R}\) be a first order differential relation for maps from \(M\) to \(N\). If, for every manifold with boundary \(P\), \(\mathcal{R}^P\) satisfies the \(h\)-principle then \(\mathcal{R}\) satisfies the parametric \(h\)-principle. Likewise, the \(C^0\)-dense and relative \(h\)-principle for all \(\mathcal{R}^P\) imply the parametric \(C^0\)-dense and relative \(h\)-principle for \(\mathcal{R}\). </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000090">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p> This obviously follows from <a href="chap-global.html#lem:param_trick">lemma 3.22</a>. </p>

  </div>
</div>
<h1 id="sec:general_theory">3.3 The \(h\)-principle for open and ample differential relations</h1>

<p>In this chapter, \(X\) and \(Y\) are smooth manifolds and \(\mathcal{R}\) is a first order differential relation on maps from \(X\) to \(Y\): \(\mathcal{R}⊂ J^1(X, Y)\). For any \(σ = (x, y, φ)\) in \(\mathcal{R}\) and any dual pair \((λ, v) ∈ T^*_xX × T_xX\), we set: </p>
<div class="displaymath" id="a0000000091">
  \[  \mathcal{R}_{σ, λ, v} = \operatorname{Conn}_{φ(v)}\left\{ w ∈ T_yY \; ;\;  \big (x,\;  y,\;  φ + (w - φ(v))⊗λ\big ) ∈ \mathcal{R}\right\}   \]
</div>
<p> where \(\operatorname{Conn}_a A\) is the connected component of \(A\) containing \(a\). In order to decipher this definition, it suffices to notice that \(φ + (w - φ(v))⊗λ\) is the unique linear map from \(T_xX\) to \(T_yY\) which coincides with \(φ\) on \(\ker λ\) and sends \(v\) to \(w\). In particular, \(w = φ(v)\) gives back \(φ\). </p>
<p>Of course we will want to deal with more than one point, so we will consider a vector field \(V\) and a \(1\)–form \(λ\) such that \(λ(V) = 1\) on some subset \(U\) of \(X\), a formal solution \(F\) (defined at least on \(U\)), and get the corresponding \(\mathcal{R}_{F, λ, v}\) over \(U\). </p>
<p>One easily checks that \(\mathcal{R}_{σ, κ^{-1}λ, κv} = κ\mathcal{R}_{σ, λ, v}\) hence the above definition only depends on \(\ker λ\) and the direction \(ℝV\). </p>
<p><div class="definition_thmwrapper" id="def:ample_relation">
  <div class="definition_thmheading">
    <span class="definition_thmcaption">
    Definition
    </span>
    <span class="definition_thmlabel">3.24</span>
    ✓
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#def:ample_relation">#</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:one_jet_space">Definition 3.12</a></li>
          <li><a href="chap-local.html#def:ample_subset">Definition 2.12</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L76">rel_mfld.ample</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="definition_thmcontent">
  <p>   A relation \(\mathcal{R}\) is ample if, for every \(σ = (x, y, φ)\) in \(\mathcal{R}\) and every \((λ, v)\), the slice \(\mathcal{R}_{σ, λ, v}\) is ample in \(T_yY\). </p>

  </div>
</div> </p>
<p><div class="lemma_thmwrapper" id="lem:ample_iff_loc">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.25</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:ample_iff_loc">#</a>
    <a class="icon proof" href="chap-global.html#a0000000092"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:ample_relation">Definition 3.24</a></li>
          <li><a href="chap-global.html#def:transfer_map">Definition 3.19</a></li>
        </ul>

      </div>
    </div>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/relation.lean#L224">rel_mfld.ample.localize</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>   Given manifolds \(W\), \(X\), \(Y\) and \(Z\) and smooth open embeddings \(g : Z → Y\) and \(h : W → X\), the relation induced (in the sense of <a href="chap-global.html#def:transfer_map">Definition 3.19</a>) in \(J^1(W, Z)\) by a ample relation in \(J^1(X, Y)\) is ample. </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000092">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>By definition, the relation induced by \(\mathcal{R}\) is \(ψ_{g, h}⁻¹\mathcal{R}\) where \(ψ_{g, h}(w, z, φ) = (h(w), g(z), T_zg ∘ φ ∘ (T_wh)⁻¹)\). Fix \(σ =(w, z, φ) ∈ ψ_{g, h}⁻¹\mathcal{R}\) and a dual pair \((λ, v)\) on \(T_wW\). We set \(G = T_z g\) and \(H = T_w h\). Both those maps are linear isomorphisms. We compute the slice corresponding to \((σ, λ, v)\): </p>
<div class="displaymath" id="a0000000093">
  \begin{align*}  ψ_{g, h}⁻¹\mathcal{R}(σ, λ, v) & = \left\{ u ∈ T_wW \; \left|\;  (w, z, φ + (u - φv)⊗λ) ∈ ψ_{g, h}⁻¹\mathcal{R}\right.\right\} \\ & = \left\{ u ∈ T_wW \; \left|\;  (h(w), g(z), G ∘(φ + (u - φv)⊗λ)∘ H⁻¹) ∈ \mathcal{R}\right.\right\} \\ & = G⁻¹\mathcal{R}((h(w), g(z), G ∘ φ ∘ H⁻¹), λ ∘ H⁻¹, Gu). \end{align*}
</div>
<p> Hence the slice \(ψ_{g, h}⁻¹\mathcal{R}(σ, λ, v)\) is the image of a slice of \(\mathcal{R}\) under a linear isomorphism, hence ample. </p>

  </div>
</div>
<p><div class="lemma_thmwrapper" id="lem:open_ample_immersion">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.26</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:open_ample_immersion">#</a>
    <a class="icon proof" href="chap-global.html#a0000000094"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p> The relation of immersions of \(M\) into \(N\) in positive codimension is open and ample. </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000094">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>  This obviously follows from <a href="chap-local.html#lem:open_ample_immersion_loc">lemma 2.15</a>. Better, we should remove <a href="chap-local.html#lem:open_ample_immersion_loc">lemma 2.15</a> and copy-paste its proof here. </p>

  </div>
</div>
<p><div class="theorem_thmwrapper" id="thm:open_ample">
  <div class="theorem_thmheading">
    <span class="theorem_thmcaption">
    Theorem
    </span>
    <span class="theorem_thmlabel">3.27</span>
    <span class="theorem_thmtitle">Gromov</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#thm:open_ample">#</a>
    <a class="icon proof" href="chap-global.html#a0000000095"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:h-princ">Definition 3.21</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="theorem_thmcontent">
  <p>   If \(\mathcal{R}\) is open and ample then it satisfies the relative and parametric \(C^0\)-dense \(h\)-principle. </p>

  </div>
</div> </p>
<p>We first explain how to get rid of parameters, using the relation \(\mathcal{R}^P\) for families of solutions parametrized by \(P\). </p>
<p><div class="lemma_thmwrapper" id="lem:ample_parameter">
  <div class="lemma_thmheading">
    <span class="lemma_thmcaption">
    Lemma
    </span>
    <span class="lemma_thmlabel">3.28</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#lem:ample_parameter">#</a>
    <a class="icon proof" href="chap-global.html#a0000000096"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal"><svg  class="icon icon-mindmap "><use xlink:href="symbol-defs.svg#icon-mindmap"></use></svg>
</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Uses</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="chap-global.html#def:ample_relation">Definition 3.24</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="lemma_thmcontent">
  <p>  If \(\mathcal{R}\) is ample then, for any parameter space \(P\), \(\mathcal{R}^P\) is also ample. </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000096">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>We fix \(σ = (x, y, ψ)\) in \(\mathcal{R}^P\). For any \(λ = (λ_X, λ_P) ∈ T^*_xX × T^*_pP\) and \(v = (v_X, v_P) ∈ T_xX × T_pP\) such that \(λ(v) = 1\), we need to prove that \(\operatorname{Conv}\mathcal{R}^P_{σ, λ, v} = T_yY\). Unfolding the definitions gives: </p>
<div class="displaymath" id="a0000000097">
  \[  \mathcal{R}^P_{σ, λ, v} = \operatorname{Conn}_{φ(v)}\left\{ w ∈ T_yY \; ;\;  \big (x,\;  y,\;  ψ ∘ ι_{x, p} + (w - ψ(v))⊗λ_X\big ) ∈ \mathcal{R}\right\} .  \]
</div>
<p> A degenerate but easy case is when \(λ_X = 0\). Then the condition on \(w\) becomes \(ψ ∘ ι_{x, p} ∈ \mathcal{R}\), which is true by definition of \(\mathcal{R}^P\), so \(\mathcal{R}^P_{σ, λ, v} = T_yY\). </p>
<p>We now assume \(λ_X\) is not zero and choose \(u ∈ T_xX\) such that \(λ_X(u) = 1\). We then have \(\mathcal{R}^P_{σ, λ, v} = \mathcal{R}_{Ψσ, λ_X, u} + ψ(v) - ψ∘ι_{x, p}(u)\). Because \(\mathcal{R}\) is ample and taking convex hull commutes with translation, we get that \(\operatorname{Conv}\mathcal{R}^P_{σ, λ, v} = T_yY\). </p>

  </div>
</div>
<div class="proof_wrapper" id="a0000000095">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof of Theorem&#160;<a href="chap-global.html#thm:open_ample">3.27</a>
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p>   Lemmas&#160;<a href="chap-global.html#lem:param_for_free">3.23</a> and&#160;<a href="chap-global.html#lem:ample_parameter">3.28</a> prove we can assume there are no parameters. So we start with a single formal solution \(F\) of \(\mathcal{R}\), which is holonomic near some closed subset \(A ⊂ X\). </p>
<p>We apply <a href="chap-global.html#lem:ex_localisation">lemma 3.5</a> to get some localisation data \((φ \! :ι → \operatorname{\mathcal{P}}{X}, ψ \! :ι' → \operatorname{\mathcal{P}}{Y}, j)\) for \(\operatorname{bs}F : X → Y\). <a href="chap-global.html#lem:localisation_stability">Lemma 3.7</a> then provides a continuous function \(ε : X → ℝ_{{\gt} 0}\) such that every function \(g\) with \(d(\operatorname{bs}F, g) {\lt} ε\) sends each \(φ_i(E)\) into \(ψ_{j(i)}(F)\). Since \(ι\) is finite or countable we can assume it is a convenient indexing set (see <a href="chap-global.html#def:convenient_indexing">Definition 3.8</a>). We denote by \(π \! :ℕ → ι\) and \(σ \! :ι → ℕ\) the corresponding structure maps. </p>
<p>We will construct by induction on \(n\) a sequence of homotopies of sections \(F_n \! :[0, 1] × X → J¹(X, Y)\) such that, for all \(n\), </p>
<ul class="itemize">
  <li><p>\(F_{n, t}(x)\) coincides with \(F(x)\) for all \(t\) if \(n = 0\) or \(x\) is close to \(A\)&#160;; </p>
</li>
  <li><p>for all \(t\), \(d(\operatorname{bs}F, \operatorname{bs}F_{n, t}) {\lt} ε\)&#160;; </p>
</li>
  <li><p>if \(π(n+1) = π(n)\) then \(F_{n+1, t}\) coincides with \(F_{n, t}\) for all \(t\)&#160;; </p>
</li>
  <li><p>\(F_{n+1, 1}\) is holonomic on \(\bigcup _{i {\lt} π(n)} φ_i(\bar B_E)\)&#160;; </p>
</li>
  <li><p>each \(F_{n+1, t}\) coincides with \(F_{n, t}\) outside \(φ_{π(n)}(E)\). </p>
</li>
</ul>
<p>The induction construction starts with setting \(F_{0, t} = F\) for all \(t\), which has the required properties (the first two conditions are clear and the other ones don’t say anything about \(F_0\)). Now assume \(F_n\) has been constructed. If \(π(n+1) = π(n)\) then we set \(F_{n+1} = F_n\). Otherwise we have \(π(n+1) {\gt} π(n)\). </p>
<p>For any \(t\), since \(d(\operatorname{bs}F, \operatorname{bs}F_{n, t}) {\lt} ε\) by induction hypothesis, \(\operatorname{bs}F_{n, t}\) sends \(φ_i(E)\) into \(ψ_{j(i)}(F)\). </p>
<p><a href="chap-global.html#def:transfer_map">Definition 3.19</a> then turns \(F_n\) into a homotopy of sections \(\mathcal{F}\) of \(J¹(E, F)\). According to <a href="chap-global.html#lem:transfer">Lemma 3.20</a>, each \(\mathcal{F}_t\) is a formal solution of the relation \(\mathcal{R}_i\) induced by \(\mathcal{R}\) in \(J¹(E, F)\) via \(φ_{π(n)}\) and \(ψ_{j(π(n))}\), \(\mathcal{F}\) is relative to \(φ_{π(n)}⁻¹(A)\) and \(\mathcal{F}_1\) is holonomic near \(φ_{π(n)}⁻¹(A ∪ \bigcup _{i {\lt} π(n)} φ_i(\bar B_E))\). </p>
<p>The new homotopy \(F_{n+1}\) will be constructed by updating \(F_n\) using some homotopy \(\mathcal{F}'\) of sections of \(J¹(E, F)\). In order to ensure \(d(\operatorname{bs}F, \operatorname{bs}F_{n+1}) {\lt} ε\), it suffices to ensure that, for each \(x\) and \(t\), either \(\mathcal{F}_{n+1, t}(x) = \mathcal{F}_{n, t'}(x)\) for some \(t'\) or \(d(\operatorname{bs}F_{n, 1}(x), \operatorname{bs}F_{n+1, t}(x)) {\lt} ε(x) - d(\operatorname{bs}F(x), \operatorname{bs}F_{n, 1}(x))\). The latter will hold as soon as, for all \(e\) and \(t\), \(‖\operatorname{bs}\mathcal{F}_1(e) - \operatorname{bs}\mathcal{F}'_t(e)‖ {\lt} η\) for some positive \(η\) given by <a href="chap-global.html#lem:updating">Lemma 3.2</a> (applied to \(M × [0, 1]\) and \(N\)). So <a href="chap-local.html#lem:improve_htpy_loc">Lemma 2.17</a> gives a suitable \(\mathcal{F}'\). </p>
<p>Now that the inductive construction is completed, we apply <a href="chap-global.html#lem:loc_ultim_const">Lemma 3.9</a> to make sure our sequence \(F_n\) is locally ultimately constant, hence it converges pointwise to a smooth homotopy relative to \(A\) and ending at a holonomic section of \(\mathcal{R}\). </p>

  </div>
</div>
<p><div class="theorem_thmwrapper" id="thm:sphere_eversion">
  <div class="theorem_thmheading">
    <span class="theorem_thmcaption">
    Theorem
    </span>
    <span class="theorem_thmlabel">3.29</span>
    <span class="theorem_thmtitle">Smale 1958</span>
    <div class="thm_icons">
    <a class="icon proof" href="chap-global.html#thm:sphere_eversion">#</a>
    <a class="icon proof" href="chap-global.html#a0000000098"><svg  class="icon icon-cogs "><use xlink:href="symbol-defs.svg#icon-cogs"></use></svg>
</a>
    <button class="modal lean">L∃∀N</button>
    <div class="modal-container">
      <div class="modal-content">
        <header>
          <h1>Lean declarations</h1>
          <button class="closebtn"><svg  class="icon icon-cross "><use xlink:href="symbol-defs.svg#icon-cross"></use></svg>
</button>
        </header>
                <ul class="uses">
          <li><a href="https://github.com/leanprover-community/sphere-eversion//blob/0f98b0d06dd387d8c105d75b4606188fc73bba4a/src/global/immersion.lean#L63">sphere_eversion</a></li>
        </ul>

      </div>
    </div>

  </div>
  </div>
  <div class="theorem_thmcontent">
  <p>  There is a homotopy of immersions of \(𝕊^2\) into \(ℝ^3\) from the inclusion map to the antipodal map \(a : q ↦ -q\). </p>

  </div>
</div> </p>
<div class="proof_wrapper" id="a0000000098">
  <div class="proof_heading">
    <span class="proof_caption">
    Proof
    </span>
    <span class="expand-proof">▼</span>
  </div>
  <div class="proof_content">
  <p> We denote by \(ι\) the inclusion of \(𝕊^2\) into \(ℝ^3\). We set \(j_t = (1-t)ι + ta\). This is a homotopy from \(ι\) to \(a\) (but not animmersion for \(t=1/2\)). Using the canonical trivialization of the tangent bundle of \(ℝ^3\), we can set, for \((q, v) ∈ T𝕊^2\), \(G_t(q, v) = \mathrm{Rot}_{Oq}^{πt}(v)\), the rotation around axis \(Oq\) with angle \(πt\). The family \(σ : t ↦ (j_t, G_t)\) is a homotopy of formal immersions relating \(j^1ι\) to \(j^1a\). It is homotopic by reparametrization to a homotopy of formal immersions relating \(j^1ι\) to \(j^1a\) which are holonomic for \(t\) near the \(0\) and \(1\). </p>
<p>The above theorem ensures this family is homotopic, relative to \(t = 0\) and \(t = 1\), to a family of holonomic formal immersions, ie a family \(t ↦ j^1f_t\) with \(f_0 = ι\), \(f_1 = a\), and each \(f_t\) is an immersion. </p>

  </div>
</div>

</div> <!--main-text -->
</div> <!-- content-wrapper -->
</div> <!-- content -->
</div> <!-- wrapper -->

<nav class="prev_up_next">
  <svg  id="showmore-minus" class="icon icon-eye-minus showmore"><use xlink:href="symbol-defs.svg#icon-eye-minus"></use></svg>

  <svg  id="showmore-plus" class="icon icon-eye-plus showmore"><use xlink:href="symbol-defs.svg#icon-eye-plus"></use></svg>

  <a href="chap-local.html" title="Local theory of convex integration"><svg  class="icon icon-arrow-left "><use xlink:href="symbol-defs.svg#icon-arrow-left"></use></svg>
</a>
  <a href="index.html" title="The sphere eversion project"><svg  class="icon icon-arrow-up "><use xlink:href="symbol-defs.svg#icon-arrow-up"></use></svg>
</a>
</nav>

<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/plastex.js"></script>
<script type="text/javascript" src="js/svgxuse.js"></script>
<script type="text/javascript" src="js/js.cookie.min.js"></script>
<script type="text/javascript" src="js/showmore.js"></script>
</body>
</html>