import Mathlib.Geometry.Manifold.Metrizable
import SphereEversion.Local.DualPair
import SphereEversion.Global.OneJetSec
import SphereEversion.Global.SmoothEmbedding
import SphereEversion.ToMathlib.Analysis.Convex.AmpleSet

/-!
# First order partial differential relations for maps between manifolds

This file contains fundamental definitions about first order partial differential relations
for maps between manifolds and relating them to the local story of first order partial differential
relations for maps between vector spaces.

Given manifolds `M` and `M'` modelled on `I` and `I'`, a first order partial differential relation
for maps from `M` to `M'` is a set in the 1-jet bundle J¬π(M, M'), also known as
`OneJetBundle I M I' M'`.
-/


noncomputable section

open Set Function

open Filter hiding map_smul

open ChartedSpace SmoothManifoldWithCorners

open scoped Topology Manifold Bundle

section Defs

/-! ## Fundamental definitions -/


variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  {H : Type*} [TopologicalSpace H] (I : ModelWithCorners ‚Ñù E H)
  (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SmoothManifoldWithCorners I M]
  {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
  {H' : Type*} [TopologicalSpace H'] (I' : ModelWithCorners ‚Ñù E' H')
  (M' : Type*) [TopologicalSpace M'] [ChartedSpace H' M'] [SmoothManifoldWithCorners I' M']
  {F : Type*} [NormedAddCommGroup F] [NormedSpace ‚Ñù F]
  {G : Type*} [TopologicalSpace G] (J : ModelWithCorners ‚Ñù F G)
  (N : Type*) [TopologicalSpace N] [ChartedSpace G N] [SmoothManifoldWithCorners J N]
  {F' : Type*} [NormedAddCommGroup F'] [NormedSpace ‚Ñù F']
  {G' : Type*} [TopologicalSpace G'] (J' : ModelWithCorners ‚Ñù F' G')
  (N' : Type*) [TopologicalSpace N'] [ChartedSpace G' N'] [SmoothManifoldWithCorners J' N']
  {EP : Type*} [NormedAddCommGroup EP] [NormedSpace ‚Ñù EP]
  {HP : Type*} [TopologicalSpace HP] (IP : ModelWithCorners ‚Ñù EP HP)
  (P : Type*) [TopologicalSpace P] [ChartedSpace HP P] [SmoothManifoldWithCorners IP P]
  {EX : Type*} [NormedAddCommGroup EX] [NormedSpace ‚Ñù EX]
  {HX : Type*} [TopologicalSpace HX] {IX : ModelWithCorners ‚Ñù EX HX}
  -- note: X is a metric space
  {X : Type*} [MetricSpace X] [ChartedSpace HX X] [SmoothManifoldWithCorners IX X]

local notation "TM" => TangentSpace I

local notation "TM'" => TangentSpace I'

/-- A first-order differential relation for maps from `M` to `N` is a subset of the 1-jet bundle. -/
@[reducible]
def RelMfld :=
  Set (OneJetBundle I M I' M')

variable {I M I' M'}
variable {R : RelMfld I M I' M'}

@[ext]
structure FormalSol (R : RelMfld I M I' M') extends OneJetSec I M I' M' where
  is_sol' : ‚àÄ x : M, toOneJetSec x ‚àà R

instance (R : RelMfld I M I' M') : FunLike (FormalSol R) M (OneJetBundle I M I' M')  where
  coe := fun F ‚Ü¶ F.toOneJetSec
  coe_injective' := by
    intro F G h
    ext x : 2
    ¬∑ exact congrArg Prod.snd (congrArg Bundle.TotalSpace.proj (congrFun h x))
    ¬∑ simpa using ((Bundle.TotalSpace.ext_iff _ _).mp (congrFun h x)).2


def mkFormalSol (F : M ‚Üí OneJetBundle I M I' M') (hsec : ‚àÄ x, (F x).1.1 = x) (hsol : ‚àÄ x, F x ‚àà R)
    (hsmooth : Smooth I ((I.prod I').prod ùìò(‚Ñù, E ‚ÜíL[‚Ñù] E')) F) : FormalSol R
    where
  bs m := (F m).1.2
  œï m := (F m).2
  smooth' := by
    convert hsmooth
    ext
    rw [hsec]
    all_goals rfl
  is_sol' m := by
    convert hsol m
    ext
    rw [hsec]
    all_goals rfl

@[simp]
theorem mkFormalSol_apply (F : M ‚Üí OneJetBundle I M I' M') (hsec : ‚àÄ x, (F x).1.1 = x)
    (hsol : ‚àÄ x, F x ‚àà R) (hsmooth : Smooth I ((I.prod I').prod ùìò(‚Ñù, E ‚ÜíL[‚Ñù] E')) ‚ÜøF) :
    (mkFormalSol F hsec hsol hsmooth : M ‚Üí OneJetBundle I M I' M') = F := by
  ext x <;> try rfl
  rw [hsec]
  rfl

@[simp]
theorem mkFormalSol_bs_apply (F : M ‚Üí OneJetBundle I M I' M') (hsec : ‚àÄ x, (F x).1.1 = x)
    (hsol : ‚àÄ x, F x ‚àà R) (hsmooth : Smooth I ((I.prod I').prod ùìò(‚Ñù, E ‚ÜíL[‚Ñù] E')) ‚ÜøF) (x : M) :
    (mkFormalSol F hsec hsol hsmooth).bs x = (F x).1.2 :=
  rfl

namespace FormalSol

@[simp]
theorem coe_mk {S : OneJetSec I M I' M'} {h : ‚àÄ x, S x ‚àà R} {x : M} : FormalSol.mk S h x = S x :=
  rfl

theorem coe_inj_iff {S T : FormalSol R} : S = T ‚Üî ‚àÄ x, S x = T x := by
  constructor
  ¬∑ rintro rfl x; rfl
  ¬∑ intro h; ext x v : 3; show (S x).1.2 = (T x).1.2; rw [h]
    show (S x).2 v = (T x).2 v; rw [h]

theorem coe_inj {S T : FormalSol R} (h : ‚àÄ x, S x = T x) : S = T :=
  coe_inj_iff.mpr h

@[simp]
theorem toOneJetSec_coe (S : FormalSol R) {x : M} : S.toOneJetSec x = S x :=
  rfl

theorem is_sol (F : FormalSol R) : ‚àÄ x, F x ‚àà R :=
  F.is_sol'

theorem coe_apply (F : FormalSol R) (x : M) : F x = ‚ü®(x, F.bs x), F.œï x‚ü© :=
  rfl

theorem fst_eq (F : FormalSol R) (x : M) : (F x).1 = (x, F.bs x) :=
  rfl

theorem snd_eq (F : FormalSol R) (x : M) : (F x).2 = F.œï x :=
  rfl

theorem is_sec (F : FormalSol R) (x : M) : (F x).1.1 = x :=
  rfl

theorem bs_eq (F : FormalSol R) (x : M) : F.bs x = (F x).1.2 :=
  rfl

end FormalSol

/-! ## Ampleness -/

open scoped Manifold Bundle

/- Porting note: the following four statements are defeq to existing assumption but not found by TC
search. There was no problem in Lean 3. -/

instance (œÉ : OneJetBundle I M I' M') :
    NormedAddCommGroup (((ContMDiffMap.snd : C^‚ä§‚üÆI.prod I', M √ó M'; I', M'‚üØ) *·µñ TM') œÉ.proj) := by
  assumption

instance (œÉ : OneJetBundle I M I' M') :
    NormedSpace ‚Ñù (((ContMDiffMap.snd : C^‚ä§‚üÆI.prod I', M √ó M'; I', M'‚üØ) *·µñ TM') œÉ.proj) := by
  assumption

instance (x : M) (x' : M') :
    NormedAddCommGroup (((ContMDiffMap.snd : C^‚ä§‚üÆI.prod I', M √ó M'; I', M'‚üØ) *·µñ TM')
    (x, x')) := by
  assumption

instance (x : M) (x' : M') :
    NormedSpace ‚Ñù (((ContMDiffMap.snd : C^‚ä§‚üÆI.prod I', M √ó M'; I', M'‚üØ) *·µñ TM')
    (x, x')) := by
  assumption

/-- The slice `R(œÉ,p)`. -/
@[pp_dot]
def RelMfld.slice (R : RelMfld I M I' M') (œÉ : OneJetBundle I M I' M') (p : DualPair <| TM œÉ.1.1) :
    Set (TM' œÉ.1.2) :=
  {w : TM' œÉ.1.2 | OneJetBundle.mk œÉ.1.1 œÉ.1.2 (p.update œÉ.2 w) ‚àà R}

/-- For some reason `rw [mem_setOf_eq]` fails after unfolding `slice`,
but rewriting with this lemma works. -/
theorem mem_slice {R : RelMfld I M I' M'} {œÉ : OneJetBundle I M I' M'} {p : DualPair <| TM œÉ.1.1}
    {w : TM' œÉ.1.2} : w ‚àà R.slice œÉ p ‚Üî OneJetBundle.mk œÉ.1.1 œÉ.1.2 (p.update œÉ.2 w) ‚àà R :=
  Iff.rfl


theorem slice_mk_update {R : RelMfld I M I' M'} {œÉ : OneJetBundle I M I' M'}
    {p : DualPair <| TM œÉ.1.1} (x : E') :
    R.slice (OneJetBundle.mk œÉ.1.1 œÉ.1.2 (p.update œÉ.2 x)) p = (R.slice œÉ p : Set E') := by
  ext1 w
  rw [mem_slice]
  change _ ‚Üî OneJetBundle.mk œÉ.proj.1 œÉ.proj.2 (DualPair.update p œÉ.snd w) ‚àà R
  convert Iff.rfl using 3
  rw [oneJetBundle_mk_snd, p.update_update]

/-- A differential relation is ample if all its slices are ample sets. -/
def RelMfld.Ample (R : RelMfld I M I' M') : Prop :=
  ‚àÄ ‚¶ÉœÉ : OneJetBundle I M I' M'‚¶Ñ (p : DualPair <| TM œÉ.1.1), AmpleSet (R.slice œÉ p)

theorem RelMfld.ample_iff (R : RelMfld I M I' M') :
    R.Ample ‚Üî
      ‚àÄ ‚¶ÉœÉ : OneJetBundle I M I' M'‚¶Ñ (p : DualPair <| TM œÉ.1.1), œÉ ‚àà R ‚Üí AmpleSet (R.slice œÉ p) := by
  simp_rw [RelMfld.Ample]
  refine ‚ü®fun h œÉ p _ ‚Ü¶ h p, fun h œÉ p x hx ‚Ü¶ ?_‚ü©
  have := @h (OneJetBundle.mk œÉ.1.1 œÉ.1.2 (p.update œÉ.2 x)) p hx
  rw [slice_mk_update] at this
  exact this x hx


/-! ## Families of formal solutions. -/

/- ./././Mathport/Syntax/Translate/Command.lean:422:11: unsupported: advanced extends in structure -/
/-- A family of formal solutions indexed by manifold `N` is a function from `N` into formal
  solutions in such a way that the function is smooth as a function of all arguments. -/
@[ext]
structure FamilyFormalSol (R : RelMfld I M I' M') extends
  FamilyOneJetSec I M I' M' J N where
  is_sol' : ‚àÄ (t : N) (x : M), toFamilyOneJetSec t x ‚àà R

instance : FunLike (FamilyFormalSol J N R) N (FormalSol R) where
  coe := fun S n ‚Ü¶ ‚ü®S.toFamilyOneJetSec n, S.is_sol' n‚ü©
  coe_injective' := by
    intro S T
    rcases S with ‚ü®S, -‚ü©
    rcases T with ‚ü®T, -‚ü©
    intro h
    have fact : ‚àÄ n, S n = T n := by
      intro n
      exact congrArg FormalSol.toOneJetSec (congrFun h n)
    congr! 1
    ext n : 2
    exact (OneJetSec.mk.inj <| fact n).1
    exact (OneJetSec.mk.inj <| fact n).2

namespace FamilyFormalSol

variable {J N J' N'}

@[simp]
theorem coe_mk {S : FamilyOneJetSec I M I' M' J N} {h : ‚àÄ t x, S t x ‚àà R} {t : N} {x : M} :
    FamilyFormalSol.mk S h t x = S t x :=
  rfl

theorem coe_mk_toOneJetSec {S : FamilyOneJetSec I M I' M' J N} {h : ‚àÄ t x, S t x ‚àà R} {t : N} :
    (FamilyFormalSol.mk S h t).toOneJetSec = S t :=
  rfl

theorem toFamilyOneJetSec_coe (S : FamilyFormalSol J N R) {t : N} {x : M} :
    S.toFamilyOneJetSec t x = S t x :=
  rfl

@[simp]
theorem toFamilyOneJetSec_eq (S : FamilyFormalSol J N R) {t : N} :
    S.toFamilyOneJetSec t = (S t).toOneJetSec :=
  rfl

theorem is_sol (S : FamilyFormalSol J N R) {t : N} {x : M} : S t x ‚àà R :=
  S.is_sol' t x

/-- Reindex a family along a smooth function `f`. -/
def reindex (S : FamilyFormalSol J' N' R) (f : C^‚àû‚üÆJ, N; J', N'‚üØ) : FamilyFormalSol J N R :=
  ‚ü®S.toFamilyOneJetSec.reindex f, fun t ‚Ü¶ S.is_sol' (f t)‚ü©

end FamilyFormalSol


/-! ## Homotopies of formal solutions. -/

/-- A homotopy of formal solutions is a family indexed by `‚Ñù` -/
abbrev HtpyFormalSol (R : RelMfld I M I' M') :=
  FamilyFormalSol ùìò(‚Ñù, ‚Ñù) ‚Ñù R

def mkHtpyFormalSol (F : ‚Ñù ‚Üí M ‚Üí OneJetBundle I M I' M') (hsec : ‚àÄ t x, (F t x).1.1 = x)
    (hsol : ‚àÄ t x, F t x ‚àà R)
    (hsmooth : Smooth (ùìò(‚Ñù).prod I) ((I.prod I').prod ùìò(‚Ñù, E ‚ÜíL[‚Ñù] E')) ‚ÜøF) : HtpyFormalSol R
    where
  bs t m := (F t m).1.2
  œï t m := (F t m).2
  smooth' := by
    convert hsmooth using 1
    ext ‚ü®t, x‚ü©
    exact (hsec t x).symm
    all_goals rfl
  is_sol' t m := by
    convert hsol t m
    ext
    rw [hsec]
    all_goals rfl

@[simp]
theorem mkHtpyFormalSol_apply (F : ‚Ñù ‚Üí M ‚Üí OneJetBundle I M I' M') (hsec : ‚àÄ t x, (F t x).1.1 = x)
    (hsol : ‚àÄ t x, F t x ‚àà R)
    (hsmooth : Smooth (ùìò(‚Ñù).prod I) ((I.prod I').prod ùìò(‚Ñù, E ‚ÜíL[‚Ñù] E')) ‚ÜøF) (t : ‚Ñù) :
    (mkHtpyFormalSol F hsec hsol hsmooth t : M ‚Üí OneJetBundle I M I' M') = F t := by
  ext x <;> try rfl
  rw [hsec]
  rfl

/-- The constant homotopy of formal solution associated to a formal solution. -/
def FormalSol.constHtpy (F : FormalSol R) : HtpyFormalSol R where
  bs _ := F.bs
  œï _ := F.œï
  smooth' := F.smooth.comp smooth_snd
  is_sol' _ := F.is_sol

variable (R)

/-- The empty homotopy of formal solution associated to any relation whose source manifold
is empty. This is required to avoid a silly nonemptyness assumption in the main theorems. -/
def emptyHtpyFormalSol [IsEmpty M] : HtpyFormalSol R where
  bs _t x := (IsEmpty.false x).elim
  œï _t x := (IsEmpty.false x).elim
  smooth' := fun ‚ü®_t, x‚ü© ‚Ü¶ (IsEmpty.false x).elim
  is_sol' _t x := (IsEmpty.false x).elim


/-! ## The h-principle -/

variable {P}

/-- A relation `R` satisfies the (non-parametric) relative C‚Å∞-dense h-principle w.r.t. a subset
`C` of the domain if for every formal solution `ùìï‚ÇÄ` that is holonomic near `C`
there is a homotopy between `ùìï‚ÇÄ` and a holonomic solution that is constant near `C` and
`Œµ`-close to `ùìï‚ÇÄ`. This is a temporary version with a slightly weaker conclusion.
The weak version has `‚àÄ x ‚àà C, ‚àÄ t : ‚Ñù, ùìï t x = ùìï‚ÇÄ x` while the strong one has
`‚àÄ·∂† x near C, ‚àÄ t, ùìï t x = ùìï‚ÇÄ x`. The strong version is easy to derive from the weak one
if we prove the weak one for *all* closed sets, see `RelMfld.satisfiesHPrinciple_of_weak`
below. The reason why the weak one is more convenient for us is we will prove
the h-principle using a sequence of homotopy of formal solutions and we don't
want to keep control of a fixed neighborhood of `C` independant from the sequence index. -/
def RelMfld.SatisfiesHPrincipleWeak (R : RelMfld I M IX X) (C : Set M) (Œµ : M ‚Üí ‚Ñù) : Prop :=
  ‚àÄ ùìï‚ÇÄ : FormalSol R,
    (‚àÄ·∂† x near C, ùìï‚ÇÄ.toOneJetSec.IsHolonomicAt x) ‚Üí
      ‚àÉ ùìï : HtpyFormalSol R,
        (‚àÄ x : M, ùìï 0 x = ùìï‚ÇÄ x) ‚àß
          (ùìï 1).toOneJetSec.IsHolonomic ‚àß
            (‚àÄ x ‚àà C, ‚àÄ t : ‚Ñù, ùìï t x = ùìï‚ÇÄ x) ‚àß ‚àÄ (t : ‚Ñù) (x : M), dist ((ùìï t).bs x) (ùìï‚ÇÄ.bs x) ‚â§ Œµ x

/-- A relation `R` satisfies the (non-parametric) relative C‚Å∞-dense h-principle w.r.t. a subset
`C` of the domain if for every formal solution `ùìï‚ÇÄ` that is holonomic near `C`
there is a homotopy between `ùìï‚ÇÄ` and a holonomic solution that is constant near `C` and
`Œµ`-close to `ùìï‚ÇÄ`. -/
def RelMfld.SatisfiesHPrinciple (R : RelMfld I M IX X) (C : Set M) (Œµ : M ‚Üí ‚Ñù) : Prop :=
  ‚àÄ ùìï‚ÇÄ : FormalSol R,
    (‚àÄ·∂† x near C, ùìï‚ÇÄ.toOneJetSec.IsHolonomicAt x) ‚Üí
      ‚àÉ ùìï : HtpyFormalSol R,
        (‚àÄ x : M, ùìï 0 x = ùìï‚ÇÄ x) ‚àß
          (ùìï 1).toOneJetSec.IsHolonomic ‚àß
            (‚àÄ·∂† x near C, ‚àÄ t : ‚Ñù, ùìï t x = ùìï‚ÇÄ x) ‚àß ‚àÄ (t : ‚Ñù) (x : M), dist ((ùìï t).bs x) (ùìï‚ÇÄ.bs x) ‚â§ Œµ x

theorem RelMfld.satisfiesHPrinciple_of_weak [FiniteDimensional ‚Ñù E] [T2Space M]
    [SigmaCompactSpace M] {R : RelMfld I M IX X} {Œµ : M ‚Üí ‚Ñù} {C : Set M} (hC : IsClosed C)
    (h : ‚àÄ A : Set M, IsClosed A ‚Üí R.SatisfiesHPrincipleWeak A Œµ) : R.SatisfiesHPrinciple C Œµ := by
  haveI := ManifoldWithCorners.metrizableSpace I M
  letI : MetricSpace M := TopologicalSpace.metrizableSpaceMetric M
  intro ùìï‚ÇÄ hùìï‚ÇÄ
  obtain ‚ü®C', hCC', hC', hùìï‚ÇÄC'‚ü© := hùìï‚ÇÄ.closed_neighborhood hC
  obtain ‚ü®ùìï, h1, h2, h3, h4‚ü© := h C' hC' ùìï‚ÇÄ hùìï‚ÇÄC'
  exact ‚ü®ùìï, h1, h2, eventually_of_mem hCC' h3, h4‚ü©

/-- A relation `R` satisfies the parametric relative C‚Å∞-dense h-principle w.r.t. manifold `P`,
`C ‚äÜ P √ó M` and `Œµ : M ‚Üí ‚Ñù` if for every family of
formal solutions `ùìï‚ÇÄ` indexed by a manifold with boundary `P` that is holonomic near `C`,
there is a homotopy `ùìï` between `ùìï‚ÇÄ` and a holonomic solution,
in such a way that `ùìï` is constant near `C` and `Œµ`-close to `ùìï‚ÇÄ`.
-/
def RelMfld.SatisfiesHPrincipleWith (R : RelMfld I M IX X) (C : Set (P √ó M)) (Œµ : M ‚Üí ‚Ñù) : Prop :=
  ‚àÄ ùìï‚ÇÄ : FamilyFormalSol IP P R,
    (-- given a family of formal solutions with parameters in `P`
      ‚àÄ·∂† p : P √ó M near C, (ùìï‚ÇÄ p.1).toOneJetSec.IsHolonomicAt p.2) ‚Üí-- holonomic near `C`
      ‚àÉ ùìï : FamilyFormalSol (ùìò(‚Ñù, ‚Ñù).prod IP) (‚Ñù √ó P) R,
        (-- then there is a homotopy of such families
          ‚àÄ (s : P) (x : M), ùìï (0, s) x = ùìï‚ÇÄ s x) ‚àß
          (-- that agrees on `t = 0`
            ‚àÄ s : P, (ùìï (1, s)).toOneJetSec.IsHolonomic) ‚àß
            (-- is holonomic everywhere for `t = 1`
              ‚àÄ·∂† p : P √ó M near C, ‚àÄ t : ‚Ñù, ùìï (t, p.1) p.2 = ùìï‚ÇÄ p.1 p.2) ‚àß-- and agrees near `C`
              ‚àÄ (t : ‚Ñù) (s : P) (x : M), dist ((ùìï (t, s)).bs x) ((ùìï‚ÇÄ s).bs x) ‚â§ Œµ x

-- and close to `ùìï‚ÇÄ`.
variable {IP}

/-- If a relation satisfies the parametric relative C‚Å∞-dense h-principle wrt some data
then we can forget the homotopy and get a family of solutions from every
family of formal solutions. -/
theorem RelMfld.SatisfiesHPrincipleWith.bs {R : RelMfld I M IX X} {C : Set (P √ó M)} {Œµ : M ‚Üí ‚Ñù}
    (h : R.SatisfiesHPrincipleWith IP C Œµ) (ùìï‚ÇÄ : FamilyFormalSol IP P R)
    (h2 : ‚àÄ·∂† p : P √ó M near C, (ùìï‚ÇÄ p.1).toOneJetSec.IsHolonomicAt p.2) :
    ‚àÉ f : P ‚Üí M ‚Üí X,
      (Smooth (IP.prod I) IX <| uncurry f) ‚àß
        (‚àÄ·∂† p : P √ó M near C, f p.1 p.2 = ùìï‚ÇÄ.bs p.1 p.2) ‚àß
          (‚àÄ p m, dist (f p m) ((ùìï‚ÇÄ p).bs m) ‚â§ Œµ m) ‚àß ‚àÄ p m, oneJetExt I IX (f p) m ‚àà R := by
  rcases h ùìï‚ÇÄ h2 with ‚ü®ùìï, _, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ‚ü©
  refine ‚ü®fun s ‚Ü¶ (ùìï (1, s)).bs, ?_, ?_, ?_, ?_‚ü©
  ¬∑ have := ùìï.toFamilyOneJetSec.smooth
    let j : C^‚àû‚üÆIP, P; ùìò(‚Ñù, ‚Ñù).prod IP, ‚Ñù √ó P‚üØ :=
      ‚ü®fun p ‚Ü¶ (1, p), Smooth.prod_mk smooth_const smooth_id‚ü©
    rw [show
        (uncurry fun s ‚Ü¶ (ùìï (1, s)).bs) =
          Prod.snd ‚àò œÄ _ (OneJetSpace I IX) ‚àò fun p : P √ó M ‚Ü¶ ùìï.reindex j p.1 p.2
          by ext; rfl]
    exact (ùìï.reindex j).toFamilyOneJetSec.smooth_bs
  ¬∑ apply h‚ÇÉ.mono
    intro x hx
    simp_rw [OneJetSec.bs_eq, FormalSol.toOneJetSec_coe, hx, FamilyOneJetSec.bs_eq,
      ùìï‚ÇÄ.toFamilyOneJetSec_coe]
  ¬∑ intro p m
    apply h‚ÇÑ
  ¬∑ intro p m
    suffices oneJetExt I IX (ùìï (1, p)).bs m = (ùìï.toFamilyOneJetSec (1, p)) m by
      rw [this]
      exact ùìï.is_sol' (1, p) m
    exact OneJetSec.isHolonomicAt_iff.mp (h‚ÇÇ p m)

end Defs

section OpenSmoothEmbedding

/-! ## Localisation of one jet sections

In order to use the local story of convex integration, we need a way to turn a
one jet section into local ones, then apply the local story to build a homotopy of one jets section
and transfer back to the original manifolds. There is a dissymetry here: we use
maps from whole vector spaces to open sets in manifold.

The global manifolds are called `M` and `N'`. We don't assume the local ones are vector spaces,
there are manifolds `X` and `Y` that will be vector spaces in the next section.
-/


variable {EX : Type*} [NormedAddCommGroup EX] [NormedSpace ‚Ñù EX]
  {HX : Type*} [TopologicalSpace HX] {IX : ModelWithCorners ‚Ñù EX HX}
  {X : Type*} [TopologicalSpace X] [ChartedSpace HX X] [SmoothManifoldWithCorners IX X]
  {EM : Type*} [NormedAddCommGroup EM] [NormedSpace ‚Ñù EM]
  {HM : Type*} [TopologicalSpace HM] {IM : ModelWithCorners ‚Ñù EM HM}
  {M : Type*} [TopologicalSpace M] [ChartedSpace HM M] [SmoothManifoldWithCorners IM M]
  {EY : Type*} [NormedAddCommGroup EY] [NormedSpace ‚Ñù EY]
  {HY : Type*} [TopologicalSpace HY] {IY : ModelWithCorners ‚Ñù EY HY}
  {Y : Type*} [TopologicalSpace Y] [ChartedSpace HY Y] [SmoothManifoldWithCorners IY Y]
  {EN : Type*} [NormedAddCommGroup EN] [NormedSpace ‚Ñù EN]
  {HN : Type*} [TopologicalSpace HN] {IN : ModelWithCorners ‚Ñù EN HN}
  {N : Type*} [TopologicalSpace N] [ChartedSpace HN N] [SmoothManifoldWithCorners IN N]
  (F : OneJetSec IM M IN N)
  (œÜ : OpenSmoothEmbedding IX X IM M) (œà : OpenSmoothEmbedding IY Y IN N)
  {R : RelMfld IM M IN N}

local notation "TM" => TangentSpace IM

local notation "TN" => TangentSpace IN

local notation "TX" => TangentSpace IX

local notation "TY" => TangentSpace IY

local notation "J¬πXY" => OneJetBundle IX X IY Y

local notation "J¬πMN" => OneJetBundle IM M IN N

local notation "IXY" => ModelWithCorners.prod (IX.prod IY) ùìò(‚Ñù, EX ‚ÜíL[‚Ñù] EY)

local notation "IMN" => ModelWithCorners.prod (IM.prod IN) ùìò(‚Ñù, EM ‚ÜíL[‚Ñù] EN)


/-! ## Transfer from J¬π(X, Y) to J¬π(M, N) and localized relations -/

/-- Transfer map between one jet bundles induced by open smooth embedding into the source and
targets. -/
@[simps! proj_fst proj_snd, pp_dot]
def OpenSmoothEmbeddingMR.transfer [Nonempty X] : OneJetBundle IX X IY Y ‚Üí OneJetBundle IM M IN N :=
  OneJetBundle.map IY IN œÜ œà fun x ‚Ü¶ (œÜ.fderiv x).symm

theorem OpenSmoothEmbeddingMR.smooth_transfer [Nonempty X] :
    Smooth ((IX.prod IY).prod ùìò(‚Ñù, EX ‚ÜíL[‚Ñù] EY)) ((IM.prod IN).prod ùìò(‚Ñù, EM ‚ÜíL[‚Ñù] EN))
      (œÜ.transfer œà) := by
  intro x
  refine SmoothAt.oneJetBundle_map (œÜ.smooth.smoothAt.comp _ smoothAt_snd)
    (œà.smooth.smoothAt.comp _ smoothAt_snd) ?_ smoothAt_id
  have' :=
    ContMDiffAt.mfderiv (fun _ ‚Ü¶ œÜ.invFun) (fun x : OneJetBundle IX X IY Y ‚Ü¶ œÜ x.1.1)
      ((œÜ.smoothAt_inv <| _).comp (x, œÜ x.1.1) smoothAt_snd)
      (œÜ.smooth.smoothAt.comp x (smooth_oneJetBundle_proj.fst x)) le_top
  ¬∑ sorry -- TODO: fix! simp_rw [œÜ.left_inv] at this; exact this
  exact mem_range_self _

theorem OneJetBundle.continuous_transfer [Nonempty X] : Continuous (œÜ.transfer œà) :=
  (OpenSmoothEmbeddingMR.smooth_transfer _ _).continuous

attribute [pp_dot] ContinuousLinearEquiv.symm

theorem OpenSmoothEmbeddingMR.range_transfer [Nonempty X] [Nonempty Y] :
    range (œÜ.transfer œà) = œÄ _ (OneJetSpace IM IN) ‚Åª¬π' range œÜ √óÀ¢ range œà := by
  ext œÉ; constructor
  ¬∑ rintro ‚ü®œÉ, rfl‚ü©; exact mk_mem_prod (mem_range_self _) (mem_range_self _)
  ¬∑ rcases œÉ with ‚ü®‚ü®x, y‚ü©, œÑ‚ü©
    rintro ‚ü®‚ü®x, rfl‚ü© : x ‚àà range œÜ, ‚ü®y, rfl‚ü© : y ‚àà range œà‚ü©
    refine ‚ü®‚ü®(x, y), ((œà.fderiv y).symm : TangentSpace IN (œà y) ‚ÜíL[‚Ñù] TangentSpace IY y) ‚àòL
      œÑ ‚àòL (œÜ.fderiv x : TangentSpace IX x ‚ÜíL[‚Ñù] TangentSpace IM (œÜ x))‚ü©, ?_‚ü©
    refine congr_arg (Bundle.TotalSpace.mk _) (ContinuousLinearMap.ext fun v ‚Ü¶ ?_)
    dsimp only [OpenSmoothEmbeddingMR.transfer, OneJetBundle.map, OneJetBundle.mk]
    /- Porting note: Lean 3 version was
    simp_rw [continuous_linear_map.comp_apply, ‚Üê œà.fderiv_coe, continuous_linear_equiv.coe_coe,
      (œÜ.fderiv x).apply_symm_apply, (œà.fderiv y).apply_symm_apply] -/
    simp only [ContinuousLinearMap.comp_apply, ‚Üê œà.fderiv_coe]
    erw [ContinuousLinearEquiv.coe_coe (œà.fderiv y), (œà.fderiv y).apply_symm_apply]
    change œÑ _ = _
    erw [(œÜ.fderiv x).apply_symm_apply]
    rfl

theorem OpenSmoothEmbeddingMR.isOpen_range_transfer [Nonempty X] [Nonempty Y] : IsOpen (range (œÜ.transfer œà)) := by
  rw [œÜ.range_transfer œà]
  exact (œÜ.isOpen_range.prod œà.isOpen_range).preimage oneJetBundle_proj_continuous

/-- localize a relation -/
def RelMfld.localize (R : RelMfld IM M IN N) [Nonempty X] : RelMfld IX X IY Y :=
  œÜ.transfer œà ‚Åª¬π' R


/- Porting note: the following two statements are defeq to existing assumptions but not found by TC
search. There was no problem in Lean 3. -/
instance (y : Y) : NormedAddCommGroup (TY y) := by assumption

instance (y : Y) : NormedSpace ‚Ñù (TY y) := by assumption

/-- Ampleness survives localization -/
theorem RelMfld.Ample.localize (hR : R.Ample) [Nonempty X] [Nonempty Y] : (R.localize œÜ œà).Ample := by
  intro x p
  have :
    (RelMfld.localize œÜ œà R).slice x p =
      (œà.fderiv x.1.2).symm '' R.slice (œÜ.transfer œà x) (p.map (œÜ.fderiv x.1.1)) := by
    ext v
    simp_rw [RelMfld.localize, ContinuousLinearEquiv.image_symm_eq_preimage, mem_preimage,
      mem_slice, mem_preimage]
    -- Porting note: the next `rw` should be part of the `simp_rw` above
    rw [mem_slice]
    dsimp only [OpenSmoothEmbeddingMR.transfer, OneJetBundle.map, oneJetBundle_mk_fst,
      oneJetBundle_mk_snd]
    simp_rw [p.map_update_comp_right, ‚Üê p.update_comp_left, OneJetBundle.mk, ‚Üê œà.fderiv_coe]
    rfl
  rw [this]
  exact (hR _).image ((œà.fderiv x.1.2).symm).toContinuousAffineEquiv

/-! ## Localized 1-jet sections -/

/-- Localize a one-jet section in two open embeddings.
  It maps `x` to `(x, y, (D_y(g))‚Åª¬π ‚àò F_œÜ(œÜ x) ‚àò D_x(œÜ))` where `y : M := g‚Åª¬π(F_{bs}(œÜ x))`. -/
@[simps]
def OneJetSec.localize (hF : range (F.bs ‚àò œÜ) ‚äÜ range œà) [Nonempty X] [Nonempty Y] : OneJetSec IX X IY Y where
  bs x := œà.invFun (F.bs <| œÜ x)
  œï x :=
    let y := œà.invFun (F.bs <| œÜ x)
    (‚Üë(œà.fderiv y).symm : TN (œà y) ‚ÜíL[‚Ñù] TY y) ‚àòL (F <| œÜ x).2 ‚àòL (œÜ.fderiv x : TX x ‚ÜíL[‚Ñù] TM (œÜ x))
  smooth' := by
    -- Porting note: next 4 lines were
    -- simp_rw [œÜ.fderiv_coe, œà.fderiv_symm_coe,
    --          mfderiv_congr_point (œà.right_inv (hF <| mem_range_self _))]
    simp_rw [œÜ.fderiv_coe, œà.fderiv_symm_coe]
    have : ‚àÄ x, mfderiv IN IY œà.invFun (œà (œà.invFun (bs F (œÜ x)))) = mfderiv _ _ _ (F.bs (œÜ x)) :=
      fun x ‚Ü¶ mfderiv_congr_point (œà.right_inv (hF <| mem_range_self x))
    simp only [this]
    refine Smooth.oneJet_comp IN (fun x' ‚Ü¶ F.bs (œÜ x')) ?_ ?_
    ¬∑ exact fun x ‚Ü¶ (œà.smoothAt_inv <| hF <| mem_range_self x).oneJetExt.comp _
        (F.smooth_bs.comp œÜ.smooth).contMDiffAt
    ¬∑ exact Smooth.oneJet_comp IM œÜ (F.smooth_eta.comp œÜ.smooth) œÜ.smooth.oneJetExt

theorem transfer_localize (hF : range (F.bs ‚àò œÜ) ‚äÜ range œà) (x : X) [Nonempty X] [Nonempty Y] :
    œÜ.transfer œà (F.localize œÜ œà hF x) = F (œÜ x) := by
  rw [OneJetSec.coe_apply, OneJetSec.localize_bs, OneJetSec.localize_œï,
    OpenSmoothEmbeddingMR.transfer, OneJetBundle.map]
  dsimp only [OneJetBundle.mk]
  ext
  ¬∑ rfl
  ¬∑ sorry -- TODO: fix! dsimp only; erw [œà.right_inv (hF <| mem_range_self x), Function.comp_apply, F.bs_eq]
  ¬∑ -- Porting note: was simp_rw [‚Üê œà.fderiv_coe, continuous_linear_map.comp_apply,
    --  continuous_linear_equiv.coe_coe, continuous_linear_equiv.apply_symm_apply]
    dsimp only
    -- Porting note: we are missing an ext lemma here.
    apply ContinuousLinearMap.ext_iff.2 (fun v ‚Ü¶ ?_)
    sorry /- TODO-BUMP erw [‚Üê œà.fderiv_coe, ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.coe_coe,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.apply_symm_apply,
      ContinuousLinearMap.comp_apply, ContinuousLinearEquiv.apply_symm_apply]
    rfl -/

theorem OneJetSec.localize_bs_fun (hF : range (F.bs ‚àò œÜ) ‚äÜ range œà) [Nonempty X] [Nonempty Y] :
    (F.localize œÜ œà hF).bs = œà.invFun ‚àò F.bs ‚àò œÜ :=
  rfl

theorem OneJetSec.localize_mem_iff [Nonempty X] [Nonempty Y] (hF : range (F.bs ‚àò œÜ) ‚äÜ range œà) {x : X} :
    F.localize œÜ œà hF x ‚àà R.localize œÜ œà ‚Üî F (œÜ x) ‚àà R := by
  rw [RelMfld.localize, mem_preimage, transfer_localize F œÜ œà hF]

theorem isHolonomicAt_localize_iff [Nonempty X] [Nonempty Y] (hF : range (F.bs ‚àò œÜ) ‚äÜ range œà) (x : X) :
    (F.localize œÜ œà hF).IsHolonomicAt x ‚Üî F.IsHolonomicAt (œÜ x) := by
  have :
    mfderiv IX IY (œà.invFun ‚àò F.bs ‚àò œÜ) x =
      (œà.fderiv (œà.invFun (F.bs (œÜ x)))).symm.toContinuousLinearMap.comp
        ((mfderiv IM IN F.bs (œÜ x)).comp (œÜ.fderiv x).toContinuousLinearMap) := by
    have h1 : MDifferentiableAt IN IY œà.invFun (F.bs (œÜ x)) :=
      (œà.smoothAt_inv <| hF <| mem_range_self _).mdifferentiableAt
    have h2 : MDifferentiableAt IM IN F.bs (œÜ x) := F.smooth_bs.mdifferentiableAt
    have h3 : MDifferentiableAt IX IM œÜ x := œÜ.smooth.mdifferentiableAt
    rw [mfderiv_comp x h1 (h2.comp x h3), mfderiv_comp x h2 h3, ‚Üê
      œà.fderiv_symm_coe' (hF <| mem_range_self _)]
    rfl
  simp_rw [OneJetSec.IsHolonomicAt]
  rw [mfderiv_congr (F.localize_bs_fun œÜ œà hF), OneJetSec.snd_eq, F.localize_œï, this]
  simp_rw [ContinuousLinearEquiv.cancel_left, ContinuousLinearEquiv.cancel_right]


/-! ## From embeddings `X ‚Ü™ M` and `Y ‚Ü™ N` to `J¬π(X, Y) ‚Ü™ J¬π(M, N)` -/

-- very slow to elaborate :-(
@[simps, pp_dot]
def OneJetBundle.embedding [Nonempty X] [Nonempty Y] :
    OpenSmoothEmbeddingMR IXY IMN (œÜ.transfer œà) ‚ä§ where
  isOpen_range := œÜ.isOpen_range_transfer œà
  smooth := œÜ.smooth_transfer œà
  -- TODO: fill these in!
  diff_injective := sorry
  induced := sorry
  inj := sorry
  -- old code also had these fields:
  -- invFun :=
  --   OneJetBundle.map IN IY œÜ.invFun œà.invFun fun x ‚Ü¶
  --     (œÜ.fderiv <| œÜ.invFun x : TX (œÜ.invFun x) ‚ÜíL[‚Ñù] TM (œÜ <| œÜ.invFun x))
  -- left_inv' {œÉ} := by
  --   rw [OpenSmoothEmbeddingMR.transfer,
  --     OneJetBundle.map_map œà.smoothAt_inv'.mdifferentiableAt
  --       œà.smooth.smoothAt.mdifferentiableAt]
  --   conv_rhs => rw [‚Üê OneJetBundle.map_id œÉ]
  --   congr 1
  --   ¬∑ rw [OpenSmoothEmbeddingMR.invFun_comp_coe]
  --   ¬∑ rw [OpenSmoothEmbeddingMR.invFun_comp_coe]
  --   ¬∑ ext x v; simp_rw [ContinuousLinearMap.comp_apply]
  --     convert (œÜ.fderiv x).symm_apply_apply v
  --     erw [œÜ.left_inv]; rfl
  -- smooth_inv := by
  --   rintro _ ‚ü®x, rfl‚ü©
  --   refine (SmoothAt.oneJetBundle_map ?_ ?_ ?_ smoothAt_id).smoothWithinAt
  --   ¬∑ refine' (œÜ.smoothAt_inv _).comp ?_ smoothAt_snd; exact mem_range_self _
  --   ¬∑ refine' (œà.smoothAt_inv _).comp ?_ smoothAt_snd; exact mem_range_self _
  --   have' :=
  --     ContMDiffAt.mfderiv (fun _ ‚Ü¶ œÜ) (fun x : OneJetBundle IM M IN N ‚Ü¶ œÜ.invFun x.1.1)
  --       (œÜ.smooth.smoothAt.comp _ smoothAt_snd)
  --       ((œÜ.smoothAt_inv _).comp _ (smooth_oneJetBundle_proj.fst (œÜ.transfer œà x))) le_top
  --   ¬∑ dsimp only [id]
  --     refine this.congr_of_eventuallyEq ?_
  --     refine Filter.eventually_of_mem ((œÜ.isOpen_range_transfer œà).mem_nhds (mem_range_self _)) ?_
  --     rw [œÜ.range_transfer œà]
  --     rintro ‚ü®‚ü®x, y‚ü©, œÑ‚ü© ‚ü®‚ü®x, rfl‚ü© : x ‚àà range œÜ, ‚ü®y, rfl‚ü© : y ‚àà range œà‚ü©
  --     simp_rw [inTangentCoordinates, œÜ.fderiv_coe]
  --     simp_rw [œÜ.transfer_proj_fst, œÜ.left_inv]
  --     congr 1
  --     simp_rw [œÜ.left_inv]
  --   exact mem_range_self _

lemma OneJetBundle.embedding_toFun [Nonempty X] [Nonempty Y] :
    (OneJetBundle.embedding œÜ œà) = (œÜ.transfer œà) := rfl


/-! ## Updating 1-jet sections and formal solutions -/

local notation "JŒò" => œÜ.update (OneJetBundle.embedding œÜ œà)

variable {K : Set X}

namespace OpenSmoothEmbeddingMR

theorem Jupdate_aux [Nonempty X] [Nonempty Y] (F : OneJetSec IM M IN N) (G : OneJetSec IX X IY Y) (m : M) :
    (JŒò F G m).1.1 = m := by
  simp_rw [OpenSmoothEmbeddingMR.update]; split_ifs with h
  ¬∑ rcases h with ‚ü®x, rfl‚ü©
    simp_rw [OneJetBundle.embedding_toFun, œÜ.transfer_proj_fst]
    sorry-- TODO: fix, was `simp_rw[... œÜ.left_inv, G.fst_eq]`
  ¬∑ rfl

variable [T2Space M]

/-- Update a global homotopy of 1-jet-sections `F` using a local one `G`. -/
def Jupdate [Nonempty X] [Nonempty Y] (F : OneJetSec IM M IN N) (G : HtpyOneJetSec IX X IY Y) (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) :
    HtpyOneJetSec IM M IN N := by
  refine FamilyOneJetSec.mk' (fun t ‚Ü¶ JŒò F (G t)) (fun t ‚Ü¶ œÜ.Jupdate_aux œà F (G t)) ?_
  refine œÜ.smooth_update _ _ _ (hK.image œÜ.continuous).isClosed ?_ ?_ smooth_snd fun x ‚Ü¶ hFG x.1
  ¬∑ exact F.smooth.comp smooth_snd
  ¬∑ exact G.smooth.comp (smooth_fst.prod_map smooth_id)

theorem Jupdate_apply [Nonempty X] [Nonempty Y] {F : OneJetSec IM M IN N} {G : HtpyOneJetSec IX X IY Y} (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t : ‚Ñù) (m : M) :
    œÜ.Jupdate œà F G hK hFG t m = JŒò F (G t) m := by
  ext; exact (œÜ.Jupdate_aux œà F (G t) m).symm; rfl; rfl

theorem Jupdate_bs [Nonempty X] [Nonempty Y] (F : OneJetSec IM M IN N) (G : HtpyOneJetSec IX X IY Y) (t : ‚Ñù)
    (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = OneJetBundle.embedding œÜ œà (G t x)) :
    (OpenSmoothEmbeddingMR.Jupdate œÜ œà F G hK hFG t).bs =
      OpenSmoothEmbeddingMR.update œÜ œà F.bs (G t).bs := by
  classical
  ext x
  -- TODO fix this, will be fun... related to changed def of update
  sorry
  /-change
    (if x ‚àà range œÜ then œÜ.transfer œà (G t (œÜ.invFun x)) else F x).1.2 =
      if x ‚àà range œÜ then _ else _
  split_ifs <;> rfl-/

theorem Jupdate_localize [Nonempty X] [Nonempty Y]
    {F : OneJetSec IM M IN N} {G : HtpyOneJetSec IX X IY Y} (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t : ‚Ñù)
    (rg : range ((œÜ.Jupdate œà F G hK hFG t).bs ‚àò œÜ) ‚äÜ range œà) (x : X) :
    (œÜ.Jupdate œà F G hK hFG t).localize œÜ œà rg x = G t x := by
  have foo : œà.invFun ((œÜ.Jupdate œà F G hK hFG t).bs (œÜ x)) = (G t).bs x := by
    simp_rw [Jupdate_bs, OpenSmoothEmbeddingMR.update_apply_embedding]
    sorry -- TODO fix, was `, OpenSmoothEmbeddingMR.left_inv]`
  ext -- This is partially failing compared to Lean 3.
  ¬∑ rfl
  ¬∑ exact foo
  ¬∑ -- Porting note: we are missing an ext lemma here.
    apply ContinuousLinearMap.ext_iff.2 (fun v ‚Ü¶ ?_)
    simp_rw [OneJetSec.snd_eq, OneJetSec.localize_œï]
    rw [foo]
    change (œà.fderiv ((G t).bs x)).symm ((JŒò F (G t) (œÜ x)).2 (œÜ.fderiv x v)) = ((G t).œï x) v
    rw [œÜ.update_apply_embedding]
    change
      (œà.fderiv ((G t).bs x)).symm
          (œà.fderiv ((G t).bs x) <| (G t).œï x <| (œÜ.fderiv x).symm <| œÜ.fderiv x v) =
        (G t).œï x v
    simp_rw [ContinuousLinearEquiv.symm_apply_apply]

/-- Update a global formal solutions `F` using a homotopy of local ones `G`. -/
@[pp_dot]
def updateFormalSol [Nonempty X] [Nonempty Y] (F : FormalSol R) (G : HtpyFormalSol (R.localize œÜ œà)) (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) : HtpyFormalSol R
    where
  toFamilyOneJetSec := œÜ.Jupdate œà F.toOneJetSec G.toFamilyOneJetSec hK hFG
  is_sol' t x := by
    simp_rw [Jupdate_apply, OpenSmoothEmbeddingMR.update, OneJetBundle.embedding_toFun]
    split_ifs
    ¬∑ exact G.is_sol
    ¬∑ exact F.is_sol x

theorem updateFormalSol_apply [Nonempty X] [Nonempty Y] {F : FormalSol R} {G : HtpyFormalSol (R.localize œÜ œà)}
    (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t x) :
    œÜ.updateFormalSol œà F G hK hFG t x = ‚ü®‚ü®x, (JŒò F (G t) x).1.2‚ü©, (JŒò F (G t) x).2‚ü© :=
  rfl

theorem updateFormalSol_bs' [Nonempty X] [Nonempty Y] {F : FormalSol R} {G : HtpyFormalSol (R.localize œÜ œà)}
    (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t) :
    (œÜ.updateFormalSol œà F G hK hFG t).bs = fun x ‚Ü¶ (JŒò F (G t) x).1.2 :=
  rfl

theorem updateFormalSol_bs [Nonempty X] [Nonempty Y] {F : FormalSol R} {G : HtpyFormalSol (R.localize œÜ œà)} (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t) :
    (œÜ.updateFormalSol œà F G hK hFG t).bs = œÜ.update œà F.bs (G t).bs := by
  rw [updateFormalSol_bs']
  ext x
  by_cases hx : x ‚àà range œÜ
  ¬∑ simp only [hx, update_of_mem_range, OneJetBundle.embedding_toFun, transfer_proj_snd]
    rfl
  ¬∑ rw [update_of_nmem_range, update_of_nmem_range]
    rfl
    exacts [hx, hx]

@[simp]
theorem updateFormalSol_apply_of_mem [Nonempty X] [Nonempty Y] {F : FormalSol R} {G : HtpyFormalSol (R.localize œÜ œà)}
    (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t) {m}
    (hx : m ‚àà range œÜ) : œÜ.updateFormalSol œà F G hK hFG t m = œÜ.transfer œà (G t <| œÜ.invFun m) := by
  rw [updateFormalSol_apply, œÜ.update_of_mem_range _ _ _ hx]
  ext
  ¬∑ change m = œÜ (œÜ.invFun m)
    sorry -- TODO: fix this! rw [œÜ.right_inv hx]
  ¬∑ rfl
  ¬∑ rfl

theorem updateFormalSol_apply_image [Nonempty X] [Nonempty Y] {F : FormalSol R} {G : HtpyFormalSol (R.localize œÜ œà)}
    (hK : IsCompact K)
    (hFG : ‚àÄ t, ‚àÄ x ‚àâ K, F (œÜ x) = (OneJetBundle.embedding œÜ œà) (G t x)) (t) {x} :
    œÜ.updateFormalSol œà F G hK hFG t (œÜ x) = œÜ.transfer œà (G t x) := by sorry
    -- TODO: fix this, was `simp`

end OpenSmoothEmbeddingMR

end OpenSmoothEmbedding
